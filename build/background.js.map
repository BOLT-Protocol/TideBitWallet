{"version":3,"file":"background.js","sources":["webpack://tidebitwallet/./src/background.js","webpack://tidebitwallet/./src/constants/config.js","webpack://tidebitwallet/./src/cores/Account.js","webpack://tidebitwallet/./src/cores/PaperWallet.js","webpack://tidebitwallet/./src/cores/SafeSigner.js","webpack://tidebitwallet/./src/cores/Signer.js","webpack://tidebitwallet/./src/cores/TideWalletCommunicator.js","webpack://tidebitwallet/./src/cores/TideWalletCore.js","webpack://tidebitwallet/./src/cores/Trader.js","webpack://tidebitwallet/./src/cores/User.js","webpack://tidebitwallet/./src/database/dbOperator.js","webpack://tidebitwallet/./src/database/indexedDB/index.js","webpack://tidebitwallet/./src/helpers/Cryptor.js","webpack://tidebitwallet/./src/helpers/Mnemonic/index.js","webpack://tidebitwallet/./src/helpers/env.js","webpack://tidebitwallet/./src/helpers/ethereumUtils.js","webpack://tidebitwallet/./src/helpers/httpAgent.js","webpack://tidebitwallet/./src/helpers/rlp.js","webpack://tidebitwallet/./src/index.js","webpack://tidebitwallet/./src/models/account.model.js","webpack://tidebitwallet/./src/models/tranasction.model.js","webpack://tidebitwallet/./src/models/transactionETH.model.js","webpack://tidebitwallet/./src/services/accountService.js","webpack://tidebitwallet/./src/services/accountServiceBase.js","webpack://tidebitwallet/./src/services/accountServiceDecorator.js","webpack://tidebitwallet/./src/services/ethereumService.js","webpack://tidebitwallet/./src/services/transactionService.js","webpack://tidebitwallet/./src/services/transactionServiceETH.js","webpack://tidebitwallet/./ui/javascript/utils/utils.js","webpack://tidebitwallet/external \"axios\"","webpack://tidebitwallet/external \"bignumber.js\"","webpack://tidebitwallet/external \"bip39\"","webpack://tidebitwallet/external \"bitcoinjs-lib\"","webpack://tidebitwallet/external \"buffer\"","webpack://tidebitwallet/external \"ethereumjs-util\"","webpack://tidebitwallet/external \"key-store\"","webpack://tidebitwallet/external \"rlp\"","webpack://tidebitwallet/external \"rxjs\"","webpack://tidebitwallet/external \"web3\"","webpack://tidebitwallet/webpack/bootstrap","webpack://tidebitwallet/webpack/runtime/compat get default export","webpack://tidebitwallet/webpack/runtime/define property getters","webpack://tidebitwallet/webpack/runtime/get javascript update chunk filename","webpack://tidebitwallet/webpack/runtime/get update manifest filename","webpack://tidebitwallet/webpack/runtime/getFullHash","webpack://tidebitwallet/webpack/runtime/global","webpack://tidebitwallet/webpack/runtime/hasOwnProperty shorthand","webpack://tidebitwallet/webpack/runtime/load script","webpack://tidebitwallet/webpack/runtime/make namespace object","webpack://tidebitwallet/webpack/runtime/hot module replacement","webpack://tidebitwallet/webpack/runtime/publicPath","webpack://tidebitwallet/webpack/runtime/jsonp chunk loading","webpack://tidebitwallet/webpack/startup"],"sourcesContent":["import { randomHex } from \"../ui/javascript/utils/utils\";\nimport \"./index\";\n\nchrome.runtime.onInstalled.addListener(() => {\n  chrome.storage.sync.set({ InstallID: randomHex(32) });\n});\n","// const env = 'production';\nconst env = 'development';\nconst apiVersion = '/api/v1';\nconst apiKey = 'yourKey';\nconst apiSecret = 'yourSecret';\n\nconst url = env === 'production' ? 'https://service.tidewallet.io' : 'https://staging.tidewallet.io';\n\nconst network_publish = false;\n// const network_publish = true;\n\nmodule.exports = {\n    url: url + apiVersion,\n    apiKey,\n    apiSecret,\n    installId: '',\n    network_publish\n}","const { Subject } = require(\"rxjs\");\nconst { ACCOUNT } = require(\"../models/account.model\");\nconst AccountServiceBase = require(\"../services/accountServiceBase\");\nconst EthereumService = require(\"../services/ethereumService\");\nconst { network_publish } = require(\"../constants/config\");\nconst TransactionBase = require(\"../services/transactionService\");\nconst ETHTransaction = require(\"../services/transactionServiceETH\");\nconst BigNumber = require(\"bignumber.js\");\n\nclass AccountCore {\n  static instance;\n  _currencies = {};\n  _messenger = null;\n  _settingOptions = [];\n  _DBOperator = null;\n\n  get currencies() {\n    return this._currencies;\n  }\n\n  get messenger() {\n    return this._messenger;\n  }\n\n  set currencies(currs) {\n    this._currencies = currs;\n  }\n\n  get settingOptions() {\n    return this._settingOptions;\n  }\n\n  set settingOptions(options) {\n    this._settingOptions = options;\n  }\n\n  constructor({TideWalletCommunicator, DBOperator, TideWalletCore}) {\n    if (!AccountCore.instance) {\n      this._messenger = null;\n      this._isInit = false;\n      this._debugMode = false;\n      this._services = [];\n      this._DBOperator = DBOperator;\n      this._TideWalletCommunicator = TideWalletCommunicator;\n      this._TideWalletCore = TideWalletCore;\n      AccountCore.instance = this;\n    }\n\n    return AccountCore.instance;\n  }\n\n  setMessenger() {\n    this._messenger = new Subject();\n  }\n\n  async init(debugMode = false) {\n    this._debugMode = debugMode;\n    this._isInit = true;\n\n    await this._initAccounts();\n  }\n\n  async _initAccounts() {\n    const chains = await this._getNetworks(network_publish);\n    const accounts = await this._getAccounts();\n    await this._getSupportedCurrencies();\n\n    for (const acc of accounts) {\n      let blockIndex = chains.findIndex(\n        (chain) => chain.networkId === acc.networkId\n      );\n\n      if (blockIndex > -1) {\n        let svc;\n        let _ACCOUNT;\n        switch (chains[blockIndex].coinType) {\n          case 60:\n          case 603:\n            svc = new EthereumService(new AccountServiceBase(this), this._TideWalletCommunicator, this._DBOperator);\n            _ACCOUNT = ACCOUNT.ETH;\n            break;\n          case 8017:\n            svc = new EthereumService(new AccountServiceBase(this), this._TideWalletCommunicator, this._DBOperator);\n            _ACCOUNT = ACCOUNT.CFC;\n            break;\n\n          default:\n        }\n\n        if (svc && !this._currencies[acc.accountid]) {\n          this._currencies[acc.accountId] = [];\n\n          this._services.push(svc);\n\n          svc.init(acc.accountId, _ACCOUNT);\n\n          await svc.start();\n        }\n      }\n    }\n\n    this._addAccount(accounts);\n  }\n\n  /**\n   * close all services\n   * @method close\n   */\n  async sync() {\n    if (this._isInit) {\n      this._services.forEach((svc) => {\n        svc.synchro(true);\n      });\n    }\n  }\n\n  /**\n   * close all services\n   * @method close\n   */\n  close() {\n    this._isInit = false;\n    this._services.forEach((svc) => {\n      svc.stop();\n    });\n\n    delete this._services;\n    this._services = [];\n\n    delete this.accounts;\n    this.accounts = [];\n\n    delete this.currencies;\n    this.currencies = {};\n\n    delete this._settingOptions;\n    this._settingOptions = [];\n  }\n\n  /**\n   * Get service by accountId\n   * @method getService\n   * @param {string} accountId The accountId\n   * @returns {Object} The service\n   */\n  getService(accountId) {\n    return this._services.find((svc) => svc.accountId === accountId);\n  }\n\n  async _getNetworks(publish = true) {\n    let networks = await this._DBOperator.networkDao.findAllNetworks();\n\n    if (!networks || networks.length < 1) {\n      try {\n        const res = await this._TideWalletCommunicator.BlockchainList();\n        const enties = res.map((n) =>\n          this._DBOperator.networkDao.entity({\n            network_id: n[\"blockchain_id\"],\n            network: n[\"name\"],\n            coin_type: n[\"coin_type\"],\n            chain_id: n[\"network_id\"],\n            publish: n[\"publish\"],\n          })\n        );\n        networks = enties;\n        await this._DBOperator.networkDao.insertNetworks(enties);\n      } catch (error) {\n        \n      }\n    }\n\n    if (this._debugMode || !publish) {\n      return networks;\n    }\n\n    if (publish) {\n      return networks.filter((n) => n.publish);\n    }\n  }\n\n  async _getAccounts() {\n    let result = await this._DBOperator.accountDao.findAllAccounts();\n\n    if (result.length < 1) {\n      result = await this._addAccount(result);\n      return result;\n    }\n\n    return result;\n  }\n\n  async _addAccount(local) {\n    try {\n      const res = await this._TideWalletCommunicator.AccountList()\n      let list = res ?? [];\n  \n      const user = await this._DBOperator.userDao.findUser();\n  \n      for (const account of list) {\n        const id = account[\"account_id\"];\n        const exist = local.findIndex((el) => el.accountId === id) > -1;\n  \n        if (!exist) {\n          const entity = this._DBOperator.accountDao.entity({\n            ...account,\n            user_id: user.userId,\n            network_id: account[\"blockchain_id\"],\n          });\n          await this._DBOperator.accountDao.insertAccount(entity);\n  \n          local.push(entity);\n        }\n      }\n    } catch (error) {\n    }\n    return local;\n  }\n\n  async _getSupportedCurrencies() {\n    const local = await this._DBOperator.currencyDao.findAllCurrencies();\n\n    if (local.length < 1) {\n      await this._addSupportedCurrencies(local);\n    }\n  }\n\n  async _addSupportedCurrencies(local) {\n    try {\n      const res = await this._TideWalletCommunicator.CurrencyList();\n\n      let list = res;\n\n      list = list\n        .filter((c) =>\n          local.findIndex((l) => l.currencyId === c[\"currency_id\"] > -1)\n        )\n        .map((c) => this._DBOperator.currencyDao.entity(c));\n\n      await this._DBOperator.currencyDao.insertCurrencies(list);\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  /**\n   * Get currency list by accountId\n   * @method getCurrencies\n   * @param {string} accountId The accountId\n   * @returns {Array} The currency list\n   */\n  getCurrencies(accountId) {\n    return this._currencies[accountId];\n  }\n\n  /**\n   * Get all currency list\n   * @method getAllCurrencies\n   * @returns {Array} The currency list\n   */\n  getAllCurrencies() {\n    return Object.values(this._currencies).reduce(\n      (list, curr) => list.concat(curr),\n      []\n    );\n  }\n\n  /**\n   * Get transaction list by accountcurrencyId\n   * @method getTransactions\n   * @param {string} accountcurrencyId The accountcurrencyId\n   * @returns {Array} The transaction list\n   */\n  async getTransactions(accountcurrencyId) {\n    const txs = await this._DBOperator.transactionDao.findAllTransactionsById(\n      accountcurrencyId\n    );\n    return txs;\n  }\n\n  /**\n   * Get receive address by accountcurrencyId\n   * @method getReceiveAddress\n   * @param {string} accountId The accountId\n   * @returns {string} The address\n   */\n   async getReceiveAddress(accountcurrencyId) {\n    const svc = this.getService(accountcurrencyId);\n    const address = await svc.getReceivingAddress(accountcurrencyId);\n    return address;\n  }\n\n  /**\n   * Send transaction\n   * @method sendTransaction\n   * @param {string} accountcurrencyId The accountcurrencyId\n   * @param {object} param The transaction content\n   * @param {number} param.amount\n   * @param {string} param.to\n   * @param {number} param.gasPrice\n   * @param {number} param.gasUsed\n   * @param {string} param.gasPrice\n   * @param {number} param.keyIndex\n   * @returns {boolean}} success\n   */\n  async sendTransaction(\n    accountCurrency,\n    { amount, to, gasPrice, gasUsed, message }\n  ) {\n    let safeSigner;\n    switch (accountCurrency.accountType) {\n      case ACCOUNT.ETH:\n      case ACCOUNT.CFC:\n        safeSigner = this._TideWalletCore.getSafeSigner(\"m/84'/3324'/0'/0/0\");\n        const svc = this.getService(accountCurrency.accountId);\n        const address = svc.getReceivingAddress(\n          accountCurrency.accountcurrencyId\n        );\n        const account = this._accounts.find(\n          (acc) => acc.accountId === svc.accountId\n        );\n\n        const nonce = await svc.getNonce(account.networkId, address);\n\n        const txSvc = new ETHTransaction(new TransactionBase(), safeSigner);\n        const signedTx = txSvc.prepareTransaction({\n          amount: BigNumber(amount),\n          to,\n          gasPrice: BigNumber(gasPrice),\n          gasUsed: BigNumber(gasUsed),\n          message,\n          nonce,\n        });\n\n        const [success, tx] = await svc.publishTransaction(\n          account.networkId,\n          signedTx\n        );\n\n        console.log(signedTx); //-- debug info\n        console.log(tx); //-- debug info\n        return success;\n      default:\n        return null;\n    }\n  }\n}\n\nmodule.exports = AccountCore;\n","const keyStore = require('key-store');\nconst bitcoin = require(\"bitcoinjs-lib\");\n\nconst Cryptor = require('../helpers/Cryptor');\n\nclass PaperWallet {\n  static EXT_PATH = \"m/84'/3324'/0'\";\n  static EXT_CHAININDEX = 0;\n  static EXT_KEYINDEX = 0;\n  static KEYSTOREID = 'keyObject'\n\n  /**\n   * keyObject: {\n   *  metadata:\n   *    { nonce: 'rFTRLcQhKxN4XoAql3u0NXxZ7P0Xy1h7', iterations: 10000 },\n   *  public: {},\n   *  private: \n   *    'wz+zDOrp7ZOUZVuG/7AfJM9GhgHXlsiXwg478GmTm9r3uFGOcFRzY2ldVN1cmSURI6YKJS2EjIMBSVh5caZcBg26sLA124+k2PPV+VrYFoYidTMvZG1XzdUQvkybP/cwQN9OedCO8fOyIwoYeqA1RGMVhjHyoqM7bdGdjknmDibrKj5pG+uu1CU+fbPVQ/TUMig='\n   * }\n   */\n\n  /**\n   * @method createWallet\n   * @param {string} privateKey\n   * @param {string} password\n   * @returns {object} keyObject\n   */\n  static async createWallet(privateKey, password) {\n    try {\n      let storage = {}\n      const keystore = keyStore.createStore((data) => {storage = data});\n      await keystore.saveKey(PaperWallet.KEYSTOREID, password, privateKey);\n\n      return storage;\n    } catch (error) {\n      console.log(error)\n    }\n  }\n\n  /**\n   * @method recoverFromJson\n   * @param {string} keyObjectJson\n   * @param {string} password\n   * @returns {string} privateKey\n   */\n  static recoverFromJson(keyObjectJson, password) {\n    try {\n      const keyObject = PaperWallet.jsonToWallet(keyObjectJson);\n      let storage = {}\n      const keystore = keyStore.createStore((data) => {storage = data}, keyObject);\n\n      const pk = keystore.getPrivateKeyData(PaperWallet.KEYSTOREID, password);\n      return pk;\n    } catch (error) {\n      console.log(error);\n      return null;\n    }\n  }\n\n  /**\n   * @method updatePassword\n   * @param {object} oriKeyObject\n   * @param {string} oriPassword\n   * @param {string} newPassword\n   * @return {object} keyObject\n   */\n  static updatePassword(oriKeyObject, oriPassword, newPassword) {\n    const pk = PaperWallet.recoverFromJson(PaperWallet.walletToJson(oriKeyObject), oriPassword);\n    return PaperWallet.createWallet(pk.toString('hex'), newPassword);\n  }\n\n  /**\n   * @method magicSeed\n   * @param {string} pk\n   * @returns {string} pk used keccak256 twice\n   */\n  static magicSeed(pk) {\n    if (pk.length < 128) {\n      return Cryptor.keccak256round(pk, 2)\n    }\n    return pk;\n  }\n\n  /**\n   * @method getPubKey\n   * @param {Buffer} seed bip seed\n   * @param {number} chainIndex - integer for hdwallet chainIndex\n   * @param {number} keyIndex - integer for hdwallet keyIndex\n   * @param {object} options\n   * @param {string} [path] - default EXT_PATH\n   * @param {boolean} [compressed] - default true\n   * @returns {string}\n   */\n  static getPubKey(seed, chainIndex, keyIndex, options = {}) {\n    const {path = PaperWallet.EXT_PATH, compressed = true } = options;\n    const dPath = `${path}/${chainIndex}/${keyIndex}`;\n    const root = bitcoin.bip32.fromSeed(seed);\n    const child = root.derivePath(dPath);\n    if (!compressed) {\n      return bitcoin.ECPair.fromPublicKey(child.publicKey, { compressed: false }).publicKey.toString('hex');\n    }\n    return child.publicKey.toString('hex');\n  }\n\n  /**\n   * @method getPriKey\n   * @param {Buffer} seed bip seed\n   * @param {number} chainIndex - integer for hdwallet chainIndex\n   * @param {number} keyIndex - integer for hdwallet keyIndex\n   * @param {object} options\n   * @param {string} [options.path] - default EXT_PATH\n   * @returns {string}\n   */\n  static getPriKey(seed, chainIndex, keyIndex, options = {}) {\n    const {path = PaperWallet.EXT_PATH } = options;\n    const dPath = `${path}/${chainIndex}/${keyIndex}`;\n    const root = bitcoin.bip32.fromSeed(seed);\n    const child = root.derivePath(dPath);\n    return child.privateKey.toString('hex');\n  }\n\n  /**\n   * @method getExtendedPublicKey\n   * @param {Buffer} seed \n   * @returns {string}\n   */\n  static getExtendedPublicKey(seed) {\n    let root = bitcoin.bip32.fromSeed(seed);\n    root = root.derivePath(PaperWallet.EXT_PATH);\n\n    const xPub = root.neutered().toBase58();\n\n    return xPub;\n  }\n\n  /**\n   * @method walletToJson\n   * @param {object} wallet - keyObject\n   * @returns {string} wallet to string\n   */\n  static walletToJson(wallet) {\n    return JSON.stringify(wallet);\n  }\n\n  /**\n   * @method jsonToWallet\n   * @param {string} walletStr - keyObject string\n   * @returns {object} keyObject\n   */\n  static jsonToWallet(walletStr) {\n    return JSON.parse(walletStr);\n  }\n}\n\nmodule.exports = PaperWallet;\n","class SafeSigner {\n  constructor(signFunction) {\n    this.signFunction = signFunction;\n  }\n\n  sign(data) {\n    return this.signFunction(data);\n  }\n}\n\nmodule.exports = SafeSigner;","const EthUtils = require('ethereumjs-util');\nconst { BN, ecsign } = EthUtils;\n\nconst ZERO32 = Buffer.alloc(32, 0);\nconst EC_GROUP_ORDER = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141', 'hex');\n\nconst THROW_BAD_HASH = 'Expected Hash';\nconst THROW_BAD_PRIVATE = 'Expected Private';\n\nclass Signer {\n  static instance;\n\n  constructor() {\n    if (!Signer.instance) {\n      this._paperWallet = null;\n      Signer.instance = this;\n    }\n\n    return Signer.instance;\n  }\n\n  /**\n   * init\n   * @param {TideWalletcore} TideWalletcore \n   * @returns \n   */\n  init(TideWalletcore) {\n    this._TideWalletcore = TideWalletcore;\n  }\n\n  static _isScalar(x) {\n    return x.length == 32;\n  }\n\n  static _compare(a, b) {\n    const aa = new BN(a);\n    const bb = new BN(b);\n    if (aa.eq(bb)) return 0;\n    if (aa.gt(bb)) return 1;\n    return -1;\n  }\n\n  static _isPrivate(x) {\n    if (!Signer._isScalar(x)) return false;\n    return Signer._compare(x, ZERO32) > 0 && // > 0\n        Signer._compare(x, EC_GROUP_ORDER) < 0; // < G\n  }\n\n  static _sign(hashData, privateKey) {\n    if(!Buffer.isBuffer(hashData) || !Signer._isScalar(hashData)) throw new Error(THROW_BAD_HASH);\n    if(!Buffer.isBuffer(privateKey) || !Signer._isPrivate(privateKey)) throw new Error(THROW_BAD_PRIVATE);\n\n    const sig = ecsign(hashData, privateKey);\n    return sig;\n  }\n\n  async sign({ keyPath, data }) {\n    return this._TideWalletcore.signBuffer({ keyPath, data })\n  }\n}\n\nmodule.exports = Signer;\n","const HTTPAgent = require('../helpers/httpAgent');\n\nclass TideWalletCommunicator {\n  static instance;\n\n  constructor ({ apiURL, apiKey, apiSecret }) {\n    if (!TideWalletCommunicator.instance) {\n      if (!apiURL) throw new Error('Invalid apiURL');\n      if (!apiKey) throw new Error('Invalid apiKey');\n      if (!apiSecret) throw new Error('Invalid apiSecret');\n      this.apiURL = apiURL;\n      this.apiKey = apiKey;\n      this.apiSecret = apiSecret;\n      this.httpAgent = new HTTPAgent({ apiURL });\n  \n      this.token;\n      this.tokenSecret;\n      TideWalletCommunicator.instance = this;\n    }\n    return TideWalletCommunicator.instance;\n  }\n\n  // 0. Get User ID and Secret\n  /**\n   * oathRegister\n   * @param {string} installID \n   * @param {*} appUUID \n   * @param {*} extendPublicKey \n   * @param {*} fcmToken \n   * @returns \n   */\n   async oathRegister(userIdentifier) {\n    let userId = '';\n    let userSecret = '';\n    try {\n      const body = {\n        id: userIdentifier\n      }\n      const res = await this.httpAgent.post(this.apiURL + '/user/id', body);\n      if (res.success) {\n        userId = res.data['user_id'];\n        userSecret = res.data['user_secret'];\n      }\n      return { userId, userSecret };\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n\n  // 7. User Regist\n  /**\n   * register\n   * @param {string} installID \n   * @param {string} appUUID \n   * @param {string} extendPublicKey \n   * @param {string} fcmToken\n   * @returns {\n   *  token: string,\n   *  tokenSecret: string,\n   *  userID: string\n   * }\n   */\n  async register(installID, appUUID, extendPublicKey, fcmToken = '') {\n    try {\n      const body = {\n        wallet_name: 'TideWallet3',\n        extend_public_key: extendPublicKey,\n        install_id: installID,\n        app_uuid: appUUID,\n        fcm_token: fcmToken\n      }\n      const res = await this.httpAgent.post(this.apiURL + '/user', body);\n      if (res.success) {\n        this.token = res.data.token;\n        this.tokenSecret = res.data.tokenSecret;\n        this.httpAgent.setToken(res.data.token);\n        return { success: true, token: res.data.token, tokenSecret: res.data.tokenSecret, userID: res.data.user_id };\n      }\n      this.token = null;\n      this.tokenSecret = null;\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 9. User Token Verify\n  /**\n   * login\n   * @param {string} token \n   * @param {string} tokenSecret \n   * @returns {\n   *  userID: string,\n   * }\n   */\n  async login(token, tokenSecret) {\n    try {\n      const res = await this.httpAgent.get(this.apiURL + '/token/verify?token=' + token);\n      if (res.success) {\n        this.token = token;\n        this.tokenSecret = tokenSecret;\n        this.httpAgent.setToken(token);\n        return { userID: res.data.user_id };\n      }\n      this.token = null;\n      this.tokenSecret = null;\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 1. List Supported Blockchains\n  /**\n   * BlockchainList\n   * @returns [{\n   *  blockchain_id: string,\n   *  name: string,\n   *  coin_type: number,\n   *  network_id: number,\n   *  publish: boolean\n   * }]\n   */\n  async BlockchainList() {\n    try {\n      const res = await this.httpAgent.get(this.apiURL + '/blockchain');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 2. Get Blockchain Detail\n  /**\n   * BlockchainDetail\n   * @param {string} blockchainID \n   * @returns {\n   *  blockchain_id: string,\n   *  name: string,\n   *  coin_type: number,\n   *  network_id: number,\n   *  publish: boolean\n   * }\n   */\n  async BlockchainDetail(blockchainID) {\n    try {\n      if (!blockchainID) return { message: 'invalid input' };\n      const res = await this.httpAgent.get(this.apiURL + '/blockchain/' + blockchainID);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 3. List Supported Currencies\n  /**\n   * CurrencyList\n   * @returns [{\n   *  currency_id: string,\n   *  blockchain_id: string,\n   *  name: string,\n   *  symbol: stirng,\n   *  type: number,\n   *  description: string,\n   *  publish: boolean,\n   *  address: string | null,\n   *  decimals: number,\n   *  total_supply: string | null,\n   *  exchange_rate: string,\n   *  contract: string | null,\n   *  icon\": string\n   * }]\n   */\n  async CurrencyList() {\n    try {\n      const res = await this.httpAgent.get(this.apiURL + '/currency');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 4. Get Currency Detail\n  /**\n   * CurrencyDetail\n   * @param {*} currencyID \n   * @returns {\n   *  currency_id: string,\n   *  blockchain_id: string,\n   *  name: string,\n   *  symbol: stirng,\n   *  type: number,\n   *  description: string,\n   *  publish: boolean,\n   *  address: string | null,\n   *  decimals: number,\n   *  total_supply: string | null,\n   *  exchange_rate: string,\n   *  contract: string | null,\n   *  icon\": string\n   * }\n   */\n  async CurrencyDetail(currencyID) {\n    try {\n      if (!currencyID) return { message: 'invalid input' };\n      const res = await this.httpAgent.get(this.apiURL + '/currency/' + currencyID);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 5. List Supported Tokens\n  /**\n   * TokenList\n   * @param {string} blockchainID \n   * @returns [{\n   *  currency_id: string,\n   *  blockchain_id: stirng,\n   *  name: string,\n   *  symbol: string,\n   *  type: number,\n   *  description: string,\n   *  publish: boolean\n   *  address: string | null,\n   *  decimals: number,\n   *  total_supply: string,\n   *  exchange_rate: string | null,\n   *  contract: string,\n   *  icon\": string\n   * }]\n   */\n  async TokenList(blockchainID) {\n    try {\n      const res = await this.httpAgent.get(this.apiURL + '/blockchain/' + blockchainID + '/token');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 6. Get Token Detail\n  /**\n   * TokenDetail\n   * @param {string} blockchainID \n   * @param {string} currencyID \n   * @returns {\n   *  currency_id: string,\n   *  blockchain_id: stirng,\n   *  name: string,\n   *  symbol: string,\n   *  type: number,\n   *  description: string,\n   *  publish: boolean\n   *  address: string | null,\n   *  decimals: number,\n   *  total_supply: string,\n   *  exchange_rate: string | null,\n   *  contract: string,\n   *  icon\": string\n   * }\n   */\n  async TokenDetail(blockchainID, currencyID) {\n    try {\n      const res = await this.httpAgent.get(this.apiURL + '/blockchain/' + blockchainID + '/token/' + currencyID);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 10. User Token Renew\n  /**\n   * AccessTokenRenew\n   * @returns {\n   *  token: string,\n   *  tokenSecret: string\n   * }\n   */\n  async AccessTokenRenew({ token, tokenSecret }) {\n    try {\n      const body = {\n        token,\n        tokenSecret\n      }\n      const res = await this.httpAgent.post(this.apiURL + '/token/renew', body);\n      if (res.success) {\n        this.token = res.data.token;\n        this.tokenSecret = res.data.tokenSecret;\n        this.httpAgent.setToken(this.token);\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 11. Account Token Regist\n  /**\n   * TokenRegist\n   * @param {string} blockchainID \n   * @param {string} contractAddress \n   * @returns {\n   *  token_id: string\n   * }\n   */\n  async TokenRegist(blockchainID, contractAddress) {\n    try {\n      if (!blockchainID || !contractAddress) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.post(this.apiURL + '/wallet/blockchain/' + blockchainID + '/contract/' + contractAddress, {});\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 12. Get Account List\n  /**\n   * AccountList\n   * @returns [{\n   *  blockchain_id: string,\n   *  currency_id: string,\n   *  purpose: number,\n   *  account_index: string,\n   *  curve_type: number,\n   *  number_of_external_key: number,\n   *  number_of_internal_key: number,\n   *  balance: string,\n   *  tokens: [tokenDetail]\n   * }]\n   */\n  async AccountList() {\n    try {\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      console.log(this.apiURL + '/wallet/accounts');\n      const res = await this.httpAgent.get(this.apiURL + '/wallet/accounts');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 13. Get Account Detail\n  /**\n   * AccountDetail\n   * @param {string} accountID \n   * @returns {\n   *  blockchain_id: string,\n   *  currency_id: string,\n   *  purpose: number,\n   *  account_index: string,\n   *  curve_type: number,\n   *  number_of_external_key: number,\n   *  number_of_internal_key: number,\n   *  balance: string,\n   *  tokens: [tokenDetail]\n   * }\n   */\n  async AccountDetail(accountID) {\n    try {\n      if (!accountID) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/wallet/account/' + accountID);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 14. Get Receive Address\n  /**\n   * AccountReceive\n   * @param {string} accountID \n   * @returns {\n   *  address: string,\n   *  keyIndex: number\n   * }\n   */\n  async AccountReceive(accountID) {\n    try {\n      if (!accountID) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/wallet/account/address/' + accountID + '/receive');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 15. Get Change Address\n  /**\n   * AccountChange\n   * @param {string} accountID \n   * @returns {\n   *  address: string,\n   *  keyIndex: number\n   * }\n   */\n  async AccountChange(accountID) {\n    try {\n      if (!accountID) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/wallet/account/address/' + accountID + '/change');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 16. List Transactions\n  /**\n   * ListTransactions\n   * @param {string} accountID \n   * @returns [{\n   *   txid: string,\n   *   status: string,\n   *   confirmations: number,\n   *   amount: string,\n   *   blockchain_id: string,\n   *   symbol: string,\n   *   direction: string,\n   *   timestamp: number,\n   *   source_addresses: array<string>,\n   *   destination_addresses: string,\n   *   fee: string,\n   *   gas_price: string | null,\n   *   gas_used: string | null\n   * }]\n   */\n  async ListTransactions(accountID) {\n    try {\n      if (!accountID) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/wallet/account/txs/' + accountID);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 17. Get Transaction Detail（暫時保留，與 list 資料重複性太高）\n  /**\n   * TransactionDetail\n   * @param {string} txid \n   * @returns {\n   *   txid: string,\n   *   status: string,\n   *   confirmations: number,\n   *   amount: string,\n   *   blockchain_id: string,\n   *   symbol: string,\n   *   direction: string,\n   *   timestamp: number,\n   *   source_addresses: array<string>,\n   *   destination_addresses: string,\n   *   fee: string,\n   *   gas_price: string | null,\n   *   gas_used: string | null\n   * }\n   */\n  async TransactionDetail(txid) {\n    try {\n      if (!txid) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/wallet/account/tx/' + txid);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 18. List Unspent Transaction Outputs\n  /**\n   * GetUTXO\n   * @param {string} accountID \n   * @returns [{\n   *   txid: string\n   *   vout: number\n   *   type: string\n   *   amount: string\n   *   script: string\n   *   timestamp: number\n   * }]\n   */\n  async GetUTXO(accountID) {\n    try {\n      if (!accountID) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/wallet/account/txs/uxto/' + accountID);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 19. Get Fee\n  /**\n   * GetFee\n   * @param {string} blockchainID \n   * @returns {\n   *  slow: string,\n   *  standard: string,\n   *  fast: string\n   * }\n   */\n  async GetFee(blockchainID) {\n    try {\n      if (!blockchainID) return { message: 'invalid input' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/blockchain/' + blockchainID + '/fee');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 20. Get Gas Limit\n  /**\n   * GetGasLimit\n   * @param {string} blockchainID \n   * @param {string} fromAddress \n   * @param {string} toAddress \n   * @param {string} value \n   * @param {string} data \n   * @returns {\n   *  gasLimit: string\n   * }\n   */\n  async GetGasLimit(blockchainID, body) {\n    try {\n      const { fromAddress, toAddress, value, data } = body;\n\n      if (!blockchainID\n        || !fromAddress\n        || !toAddress\n        || !value\n        || !data\n        ) return { message: 'invalid input' };\n\n      const res = await this.httpAgent.post(this.apiURL + '/blockchain/' + blockchainID + '/gas-limit', body);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 21. Get Nonce\n  /**\n   * GetNonce\n   * @param {string} blockchainID \n   * @param {string} address \n   * @returns {\n   *  nonce: string\n   * }\n   */\n  async GetNonce(blockchainID, address) {\n    try {\n      if (!blockchainID || !address) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/blockchain/'+ blockchainID + '/address/' + address + '/nonce');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 22. Publish Transaction\n  /**\n   * PublishTransaction\n   * @param {string} blockchainID \n   * @param {string} accountID \n   * @param {string} hex - transaction hex string\n   * @returns {}\n   */\n  async PublishTransaction(blockchainID, body) {\n    try {\n      const { hex } = body;\n\n      if (!hex) return { message: 'invalid input' };\n      if (!this.httpAgent.getToken()) return { message: 'need login' };\n\n      const res = await this.httpAgent.post(this.apiURL + '/blockchain/' + blockchainID + '/push-tx/', body);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 23. List Fiat Currency Rate\n  /**\n   * FiatsRate\n   * @returns [{\n   *  currency_id: string,\n   *  name: string,\n   *  rate: string\n   * }]\n   */\n  async FiatsRate() {\n    try {\n      const res = await this.httpAgent.get(this.apiURL + '/fiats/rate');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 24. List Crypto Currency Rate\n  /**\n   * CryptoRate\n   * @returns [{\n   *  currency_id: string,\n   *  name: string,\n   *  rate: string\n   * }]\n   */\n   async CryptoRate() {\n    try {\n      const res = await this.httpAgent.get(this.apiURL + '/crypto/rate');\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  // 25. Get Token Info\n  /**\n   * TokenInfo\n   * @param {string} blockchainID \n   * @param {string} contractAddress \n   * @returns {\n   *  symbol: string,\n   *  name\": string,\n   *  contract: string,\n   *  decimal: number\n   *  total_supply: string,\n   *  description: string | null,\n   *  imageUrl: string\n   * }\n   */\n  async TokenInfo(blockchainID, contractAddress) {\n    try {\n      if (!blockchainID || !contractAddress) return { message: 'invalid input' };\n\n      const res = await this.httpAgent.get(this.apiURL + '/blockchain/' + blockchainID + '/contract/' + contractAddress);\n      if (res.success) {\n        return res.data;\n      }\n      return Promise.reject({ message: res.message, code: res.code });\n    } catch (error) {\n      return Promise.reject({ message: error });\n    }\n  }\n\n  \n}\n\nmodule.exports = TideWalletCommunicator;","const PaperWallet = require('./PaperWallet');\nconst Signer = require('./Signer');\nconst SafeSigner = require('./SafeSigner');\nconst Cryptor = require('../helpers/Cryptor');\nconst rlp = require(\"../helpers/rlp\");\n\nclass TideWalletCore {\n  static instance;\n\n  constructor() {\n    if (!TideWalletCore.instance) {\n      this._userInfo = {};\n      TideWalletCore.instance = this;\n    }\n\n    return TideWalletCore.instance;\n  }\n\n  /**\n   * initial\n   * @param {Object} userInfo\n   * @param {String} userInfo.id\n   * @param {String} userInfo.thirdPartyId\n   * @param {String} userInfo.installId\n   * @param {Number} userInfo.timestamp\n   * @param {string} userInfo.keystore\n   * @returns \n   */\n   setUserInfo(userInfo) {\n    this._userInfo = userInfo;\n    console.log(userInfo)\n  }\n\n  /**\n   * get nonce\n   * @param {String} userIdentifier\n   * @returns {String}\n   */\n   _getNonce(userIdentifier) {\n    const cafeca = 0xcafeca;\n    let nonce = cafeca;\n\n    const getString = (nonce) =>\n      Cryptor.keccak256round(\n        Buffer.concat([\n          Buffer.from(userIdentifier, \"utf8\"),\n          rlp.toBuffer(nonce),\n        ]).toString(\"hex\"),\n        1\n      )\n        .slice(0, 3)\n        .toLowerCase();\n\n    while (getString(nonce) != \"cfc\") {\n      nonce = Number(nonce) + 1;\n    }\n\n    return nonce;\n  }\n\n  /**\n   * get password\n   * @param {Object} userInfo\n   * @param {String} userInfo.userIdentifier\n   * @param {String} userInfo.userId\n   * @param {String} userInfo.installId\n   * @param {Number} userInfo.timestamp\n   * @returns {String} password\n   */\n   _getPassword({ userIdentifier, userId, installId, timestamp }) {\n    const userIdentifierBuff = Buffer.from(userIdentifier, \"utf8\").toString(\n      \"hex\"\n    );\n    const installIdBuff = Buffer.from(installId).toString(\"hex\");\n    const pwseed = Cryptor.keccak256round(\n      Buffer.concat([\n        Buffer.from(\n          Cryptor.keccak256round(\n            Buffer.concat([\n              Buffer.from(\n                Cryptor.keccak256round(\n                  userIdentifierBuff || this._userInfo.thirdPartyId,\n                  1\n                )\n              ),\n              Buffer.from(Cryptor.keccak256round(userId || this._userInfo.id, 1)),\n            ]).toString()\n          )\n        ),\n        Buffer.from(\n          Cryptor.keccak256round(\n            Buffer.concat([\n              Buffer.from(\n                Cryptor.keccak256round(\n                  rlp\n                    .toBuffer(\n                      rlp.toBuffer(timestamp).toString(\"hex\").slice(3, 6)\n                    )\n                    .toString(\"hex\"),\n                  1\n                )\n              ),\n              Buffer.from(\n                Cryptor.keccak256round(installIdBuff || this._userInfo.installId, 1)\n              ),\n            ]).toString()\n          )\n        ),\n      ]).toString()\n    );\n    const password = Cryptor.keccak256round(pwseed);\n    return password;\n  }\n\n  _generateUserSeed({\n    userIdentifier,\n    userId,\n    userSecret,\n  }) {\n    const nonce = this._getNonce(userIdentifier);\n\n    const userIdentifierBuff = Buffer.from(userIdentifier, \"utf8\").toString(\n      \"hex\"\n    );\n    const _main = Buffer.concat([\n      Buffer.from(userIdentifierBuff, \"utf8\"),\n      rlp.toBuffer(nonce),\n    ])\n      .toString()\n      .slice(0, 16);\n\n    const _extend = Cryptor.keccak256round(\n      rlp.toBuffer(nonce).toString(\"hex\"),\n      1\n    ).slice(0, 8);\n\n    const seed = Cryptor.keccak256round(\n      Buffer.concat([\n        Buffer.from(\n          Cryptor.keccak256round(\n            Buffer.concat([\n              Buffer.from(Cryptor.keccak256round(_main, 1)),\n              Buffer.from(Cryptor.keccak256round(_extend, 1)),\n            ]).toString()\n          )\n        ),\n        Buffer.from(\n          Cryptor.keccak256round(\n            Buffer.concat([\n              Buffer.from(Cryptor.keccak256round(userId, 1)),\n              Buffer.from(Cryptor.keccak256round(userSecret, 1)),\n            ]).toString()\n          )\n        ),\n      ]).toString()\n    );\n    return {seed, _extend};\n  }\n\n  /**\n   * generate Credential Data\n   * @param {Object} userInfo\n   * @param {String} userInfo.userIdentifier\n   * @param {String} userInfo.userId\n   * @param {String} userInfo.userSecret\n   * @param {String} userInfo.installId\n   * @param {Number} userInfo.timestamp\n   * @returns {Object} result\n   * @returns {String} result.key\n   * @returns {String} result.password\n   * @returns {String} result.extend\n   */\n  _generateCredentialData({\n    userIdentifier,\n    userId,\n    userSecret,\n    installId,\n    timestamp,\n  }) {\n    const {seed, _extend} = this._generateUserSeed({ userIdentifier, userId, userSecret });\n\n    const key = Cryptor.keccak256round(seed);\n    const password = this._getPassword({\n      userIdentifier,\n      userId,\n      installId,\n      timestamp,\n    });\n\n    return { key, password, extend: _extend };\n  }\n\n  /**\n   * createWallet\n   * @param {Object} userInfo\n   * @param {String} userInfo.userIdentifier\n   * @param {String} userInfo.userId\n   * @param {String} userInfo.userSecret\n   * @param {String} userInfo.installId\n   * @param {Number} userInfo.timestamp\n   * @returns {Object} result\n   * @returns {object} result.wallet - keyObject\n   * @returns {String} result.extendPublicKey\n   */\n  async createWallet({\n    userIdentifier,\n    userId,\n    userSecret,\n    installId,\n    timestamp,\n  }) {\n    const credentialData = this._generateCredentialData({\n      userIdentifier,\n      userId,\n      userSecret,\n      installId,\n      timestamp,\n    });\n    const wallet = await PaperWallet.createWallet(\n      credentialData.key,\n      credentialData.password\n    );\n    const privateKey = PaperWallet.recoverFromJson(\n      PaperWallet.walletToJson(wallet),\n      credentialData.password\n    );\n    const seed = await PaperWallet.magicSeed(privateKey);\n    const _seed = Buffer.from(seed);\n    const extendPublicKey = PaperWallet.getExtendedPublicKey(_seed);\n    return { wallet, extendPublicKey }\n  }\n\n  /**\n   * createWalletWithSeed\n   * @param {Object} userInfo\n   * @param {String} userInfo.seed\n   * @param {String} userInfo.userIdentifier\n   * @param {String} userInfo.userId\n   * @param {String} userInfo.installId\n   * @param {Number} userInfo.timestamp\n   * @returns {Object} result\n   * @returns {object} result.wallet - keyObject\n   * @returns {String} result.extendPublicKey\n   */\n  async createWalletWithSeed({\n    seed,\n    userIdentifier,\n    userId,\n    installId,\n    timestamp,\n  }) {\n    const password = this._getPassword({\n      userIdentifier,\n      userId,\n      installId,\n      timestamp,\n    });\n    const wallet = await PaperWallet.createWallet(\n      seed,\n      password\n    );\n    const _seed = Buffer.from(seed);\n    const extendPublicKey = PaperWallet.getExtendedPublicKey(_seed);\n    return { wallet, extendPublicKey }\n  }\n\n  /**\n   * _getSeedByKeyStore\n   * @returns {string} seed\n   */\n  async _getSeedByKeyStore() {\n    const password = this._getPassword({\n      userIdentifier: this._userInfo.thirdPartyId,\n      userId: this._userInfo.id,\n      installId: this._userInfo.installId,\n      timestamp: this._userInfo.timestamp\n    })\n    const keystore = this._userInfo.keystore;\n    const pk = PaperWallet.recoverFromJson(keystore, password);\n    const seed = PaperWallet.magicSeed(pk);\n    return seed;\n  }\n  \n  /**\n   * getExtendedPublicKey\n   * @returns {string} extPK\n   */\n  async getExtendedPublicKey() {\n    const seed = await this._getSeedByKeyStore();\n    const extPK = PaperWallet.getExtendedPublicKey(Buffer.from(seed));\n    return extPK;\n  }\n\n  getSafeSigner(keyPath) {\n    const safeSigner = new SafeSigner((data) => {\n      return this.signBuffer({ keyPath, data });\n    });\n  }\n\n  //////////////////////////////////////////////////////////////////////\n\n  // /**\n  //  * \n  //  * @param {object} param\n  //  * @param {object} param.keyPath\n  //  * @param {number} param.keyPath.chainIndex\n  //  * @param {number} param.keyPath.keyIndex\n  //  * @param {Buffer} param.buffer -  hash data buffer\n  //  * @returns \n  //  */\n  // async sign({ keyPath, buffer }) {\n  //   return this._signer.sign(buffer, keyPath.chainIndex, keyPath.keyIndex);\n  // }\n\n  /**\n   * \n   * @param {object} param\n   * @param {string} param.keyPath\n   * @param {Buffer} param.data -  hash data buffer\n   * @returns \n   */\n  async signBuffer({ keyPath, data }) {\n    const {chainIndex, keyIndex, options} = Cryptor.pathParse(keyPath);\n    const seed = await this._getSeedByKeyStore();\n    const privateKey = PaperWallet.getPriKey(Buffer.from(seed, 'hex'), chainIndex, keyIndex, options);\n    return Signer._sign(data, Buffer.from(privateKey, 'hex'));\n  }\n\n  async signData({ keyPath, jsonData }) {\n    return true;\n  }\n\n  async signTransaction({ keyPath, coinType, value, data }) {\n    return true;\n  }\n}\n\nmodule.exports = TideWalletCore;\n","const BigNumber = require('bignumber.js');\n\nclass Trader {\n  static syncInterval = 24 * 60 * 60 * 1000;\n  static instance;\n\n  constructor({TideWalletCommunicator, DBOperator}) {\n    if (!Trader.instance) {\n      this._fiats = [];\n      this._cryptos = [];\n\n      this._TideWalletCommunicator = TideWalletCommunicator;\n      this._DBOperator = DBOperator;\n      Trader.instance = this;\n    }\n\n    return Trader.instance;\n  }\n\n  async getFiatList() {\n    const local = await this._DBOperator.exchangeRateDao.findAllExchageRates();\n    const now = Date.now();\n\n    if (!Array.isArray(local) || !local[0] || now - local[0].lastSyncTime > Trader.syncInterval) {\n      try {\n        const fiats = await this._TideWalletCommunicator.FiatsRate();\n        const cryptos = await this._TideWalletCommunicator.CryptoRate();\n        const rates = [\n          ...fiats.map(\n            (e) => this._DBOperator.exchangeRateDao.entity({\n              ...e, timestamp: now, type: 'fiat',\n            })\n          ),\n          ...cryptos.map(\n            (e) => this._DBOperator.exchangeRateDao.entity({\n              ...e, timestamp: now, type: 'currency',\n            })\n          )\n        ];\n        await this._DBOperator.exchangeRateDao.insertExchangeRates(rates);\n\n        this._fiats = fiats\n          .map((r) => ({\n            currencyId: r.currency_id,\n            name: r.name,\n            exchangeRate: new BigNumber(r.rate),\n          }));\n        this._cryptos = cryptos\n          .map((r) => ({\n            currencyId: r.currency_id,\n            name: r.name,\n            exchangeRate: new BigNumber(r.rate),\n          }));\n      } catch (error) {\n        console.log(error);\n      }\n    } else {\n      this._fiats = local\n        .filter((rate) => rate.type === 'fiat')\n        .map((r) => ({\n          currencyId: r.exchangeRateId,\n          name: r.name,\n          exchangeRate: new BigNumber(r.rate),\n        }));\n      this._cryptos = local\n        .filter((rate) => rate.type === 'currency')\n        .map((r) => ({\n          currencyId: r.exchangeRateId,\n          name: r.name,\n          exchangeRate: new BigNumber(r.rate),\n        }));\n    }\n\n    return this._fiats;\n  }\n\n  /**\n   * \n   * @param {object} fiat\n   * @param {string} fiat.name\n   */\n  setSelectedFiat(fiat) {\n    this._DBOperator.prefDao.setSelectedFiat(fiat.name);\n  }\n\n  async getSelectedFiat() {\n    const name = await this._DBOperator.prefDao.getSelectedFiat();\n\n    if (name == null || name == undefined) return this._fiats[0];\n\n    const fiat = this._fiats.find((f) => f.name === name);\n    return fiat;\n  }\n\n  /**\n   * calculateToUSD\n   * @param {object} _currency\n   * @param {string} _currency.currencyId\n   * @param {BigNumber} _currency.amount\n   * @returns {BigNumber} \n   */\n  calculateToUSD(_currency) {\n    const crypto = this._cryptos.find((c) => c.currencyId === _currency.currencyId);\n    if (!crypto) return new BigNumber(0);\n\n    const bnAmount = _currency.amount;\n    const bnExCh = new BigNumber(crypto.exchangeRate);\n    return bnAmount.multipliedBy(bnExCh);\n  }\n\n  /**\n   * calculateUSDToCurrency\n   * @param {object} _currency\n   * @param {string} _currency.currencyId\n   * @param {BigNumber} amountInUSD \n   * @returns {BigNumber}\n   */\n  calculateUSDToCurrency(_currency, amountInUSD) {\n    const crypto = this._cryptos.find((c) => c.currencyId === _currency.currencyId);\n    if (!crypto) return new BigNumber(0);\n\n    const bnAmountInUSD = amountInUSD;\n    const bnExCh = new BigNumber(crypto.exchangeRate);\n    return bnAmountInUSD.dividedBy(bnExCh);\n  }\n\n  /**\n   * calculateAmountToUSD\n   * @param {object} _currency\n   * @param {string} _currency.currencyId\n   * @param {BigNumber} amount \n   * @returns {BigNumber}\n   */\n  calculateAmountToUSD(_currency, amount) {\n    const crypto = this._cryptos.find((c) => c.currencyId === _currency.currencyId);\n    if (!crypto) return new BigNumber(0);\n\n    const bnAmount = amount;\n    const bnExCh = new BigNumber(crypto.exchangeRate);\n    return bnAmount.multipliedBy(bnExCh);\n  }\n\n  /**\n   * \n   * @param {object} sellCurrency\n   * @param {string} sellCurrency.currencyId\n   * @param {object} buyCurrency\n   * @param {string} buyCurrency.currencyId\n   * @param {BigNumber} sellAmount \n   * @returns {object} result\n   * @returns {BigNumber} result.buyAmount\n   * @returns {BigNumber} result.exchangeRate\n   */\n  getSwapRateAndAmount(sellCurrency, buyCurrency, sellAmount) {\n    // const sellCryptos = this._cryptos.find((c) => c.currencyId == sellCurrency.currencyId);\n    // const buyCryptos = this._cryptos.find((c) => c.currencyId == buyCurrency.currencyId);\n    // console.log(\n    //     `sellCryptos ${sellCryptos.name} [${sellCryptos.currencyId}]: ${sellCryptos.exchangeRate}`);\n    // console.log(\n    //     `buyCryptos ${buyCryptos.name} [${buyCryptos.currencyId}]: ${buyCryptos.exchangeRate}`);\n\n    const exchangeRate = this.calculateUSDToCurrency(buyCurrency, this.calculateAmountToUSD(sellCurrency, new BigNumber(1)));\n    const buyAmount = this.calculateUSDToCurrency(buyCurrency, sellAmount.multipliedBy(exchangeRate));\n    console.log('buyAmount.toFixed():', buyAmount.toFixed())\n    console.log('exchangeRate.toFixed():', exchangeRate.toFixed())\n    return {buyAmount, exchangeRate};\n  }\n}\n\nmodule.exports = Trader;\n","const PaperWallet = require(\"./PaperWallet\");\nconst TideWalletCore = require(\"./TideWalletCore\");\nconst config = require(\"../constants/config\");\nconst Mnemonic = require(\"../helpers/Mnemonic\");\n\nclass User {\n  constructor({TideWalletCommunicator, DBOperator}) {\n    this.id = null;\n    this.thirdPartyId = null;\n    this.installId = null;\n    this.timestamp = null;\n    this.isBackup = false;\n\n    this._communicator = TideWalletCommunicator;\n    this._DBOperator = DBOperator;\n    this._TideWalletCore = new TideWalletCore();\n  }\n\n  /**\n   * check user\n   * @returns {boolean}\n   */\n  async checkUser() {\n    // TODO: find user table\n    const user = await this._DBOperator.userDao.findUser();\n\n    // TODO: Remove this log\n    console.log(\"checkUser: \", user);\n\n    if (user) {\n      await this._initUser(user);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * create user\n   * @param {String} userIdentifier\n   * @param {String} _installId\n   * @returns {Boolean} success\n   */\n  async createUser(userIdentifier, _installId = \"\") {\n    const installId = config.installId || _installId;\n\n    const user = await this._getUser(userIdentifier);\n    const userId = user[0];\n    const userSecret = user[1];\n    const timestamp = Math.floor(new Date() / 1000);\n    const { wallet, extendPublicKey: extPK } = await this._TideWalletCore.createWallet({\n      userIdentifier,\n      userId,\n      userSecret,\n      installId,\n      timestamp,\n    });\n\n    const success = await this._registerUser({\n      extendPublicKey: extPK,\n      installId,\n      wallet,\n      userId,\n      userIdentifier,\n      timestamp,\n    });\n\n    return this._TideWalletCore;\n  }\n\n  /**\n   * get user\n   * @param {String} userIdentifier\n   * @returns {String[]} [userId, userSecret]\n   */\n  async _getUser(userIdentifier) {\n    let userId = \"\";\n    let userSecret = \"\";\n\n    try {\n      const _res = await this._communicator.oathRegister(userIdentifier);\n      userId = _res.userId;\n      userSecret = _res.userSecret;\n    } catch (error) {\n      console.log('_getUser:', error)\n    }\n    return [userId, userSecret];\n  }\n\n  /**\n   * register user\n   * @param {Object} userInfo\n   * @param {String} userInfo.extendPublicKey\n   * @param {String} userInfo.installId\n   * @param {object} userInfo.wallet\n   * @param {String} userInfo.userId\n   * @param {String} userInfo.userIdentifier\n   * @param {Number} userInfo.timestamp\n   * @returns {String[]} [userId, userSecret]\n   */\n  async _registerUser({\n    extendPublicKey,\n    installId,\n    wallet,\n    userId,\n    userIdentifier,\n    timestamp,\n  }) {\n    const payload = {\n      wallet_name: \"TideWallet3\", // ++ inform backend to update [Emily 04/01/2021]\n      extend_public_key: extendPublicKey,\n      install_id: installId,\n      app_uuid: installId,\n    };\n    console.log('_registerUser With: ', payload)\n\n    try {\n      const res = await this._communicator.register(installId, installId, extendPublicKey);\n\n      await this._DBOperator.prefDao.setAuthItem(\n        res.token,\n        res.tokenSecret\n      );\n\n      const keystore = await PaperWallet.walletToJson(wallet);\n      const user = this._DBOperator.userDao.entity({\n        user_id: userId,\n        keystore,\n        third_party_id: userIdentifier,\n        install_id: installId,\n        timestamp,\n        backup_status: false,\n      });\n      await this._DBOperator.userDao.insertUser(user);\n      await this._initUser(user);\n      return true;\n    } catch (error) {\n      console.log('_registerUser:', error);\n      return false;\n    }\n  }\n\n  /**\n   * create user with seed\n   * @param {String} userIdentifier\n   * @param {String} seed\n   * @returns {Boolean} success\n   */\n  async createUserWithSeed(userIdentifier, seed, _installId = \"\") {\n    const installId = config.installId || _installId;\n    const user = await this._getUser(userIdentifier);\n    const userId = user[0];\n    const timestamp = Math.floor(new Date() / 1000);\n    \n    const { wallet, extendPublicKey: extPK } = await this._TideWalletCore.createWalletWithSeed({\n      seed,\n      userIdentifier,\n      userId,\n      installId,\n      timestamp,\n    });\n\n    const success = await this._registerUser({\n      extendPublicKey: extPK,\n      installId,\n      wallet,\n      userId,\n      userIdentifier,\n      timestamp,\n    });\n\n    return this._TideWalletCore;\n  }\n\n  /**\n   * verify password -\n   * @param {String} password\n   * @returns {} not\n   */\n  verifyPassword(password) {\n    // return _seasonedPassword(password) == this._passwordHash;\n  }\n\n  /**\n   * update password - Deprecated\n   * @param {String} oldPassword\n   * @param {String} newpassword\n   * @returns {}\n   */\n  async updatePassword(oldPassword, newpassword) {\n    const user = await this._DBOperator.userDao.findUser();\n\n    const wallet = await this.restorePaperWallet(user.keystore, oldPassword);\n  }\n\n  /**\n   * valid PaperWallet\n   * @param {String} wallet\n   * @returns {}\n   */\n  validPaperWallet(wallet) {\n    try {\n      let v = wallet;\n\n      if (typeof wallet === \"string\") v = PaperWallet.jsonToWallet(wallet);\n\n      return v.keyObject.private != null;\n    } catch (e) {\n      console.warn(e);\n    }\n\n    return false;\n  }\n\n  /**\n   * jsonToWallet\n   * @param {String} keystore\n   * @param {String} pwd\n   * @returns {WalletObject} wallet\n   */\n  async restorePaperWallet(keystore, pwd) {\n    try {\n      const w = PaperWallet.jsonToWallet(keystore);\n      // valid pwd\n      PaperWallet.recoverFromJson(keystore, pwd);\n\n      return w;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  /**\n   * checkWalletBackup\n   * @param {String} oldPassword\n   * @param {String} newpassword\n   * @returns isBackup\n   */\n  async checkWalletBackup() {\n    const _user = await this._DBOperator.userDao.findUser();\n    if (_user != null) {\n      return _user.backupStatus;\n    }\n    return false;\n  }\n\n  /**\n   * backup wallet\n   * @returns {Boolean} isBackup\n   */\n  async backupWallet() {\n    try {\n      const _user = await this._DBOperator.userDao.findUser();\n\n      // TODO: updateUser condition\n      await this._DBOperator.userDao.updateUser({ backupStatus: true });\n      this.isBackup = true;\n    } catch (e) {\n      console.warn(e);\n    }\n\n    return this.isBackup;\n  }\n\n  /**\n   * init user\n   * @param {object} user - db user table\n   */\n  async _initUser(user) {\n    this.id = user.userId;\n    this.thirdPartyId = user.thirdPartyId;\n    this.installId = user.installId;\n    this.timestamp = user.timestamp;\n    this.isBackup = user.backupStatus;\n\n    const userInfo = {\n      id: user.userId,\n      thirdPartyId: user.thirdPartyId,\n      installId: user.installId,\n      timestamp: user.timestamp,\n      keystore: user.keystore\n    }\n    this._TideWalletCore.setUserInfo(userInfo);\n\n    const item = await this._DBOperator.prefDao.getAuthItem();\n    if (item != null) {\n      let _token = item.token\n      let _tokenSecret = item.tokenSecret\n      try {\n        await this._communicator.AccessTokenRenew({\n            token: _token,\n            tokenSecret: _tokenSecret\n          })\n        await this._communicator.login(_token, _tokenSecret);\n      } catch (e) {\n        console.trace(e);\n        const res = await this._communicator.register(this.installId, this.installId, await this._TideWalletCore.getExtendedPublicKey());\n\n        if (res.token) {\n          _token = res.token\n          _tokenSecret = res.tokenSecret\n          await this._DBOperator.prefDao.setAuthItem(\n            _token,\n            _tokenSecret\n          );\n        }\n      }\n\n      // verify, if not verify, set token null\n      await this._communicator.login(_token, _tokenSecret);\n    }\n  }\n\n  /**\n   * init user\n   * @param {String} password\n   * @returns {}\n   */\n  _seasonedPassword(password) {\n    // const tmp = Cryptor.keccak256round(password, 3);\n    // const bytes = Buffer.from(tmp);\n    // return String.fromCharCodes(bytes);\n    // TODO: _prefManager.getAuthItem and check is auth, or HTTPAgent().setToken(token);\n  }\n\n  /**\n   * get keystore\n   * @returns {String} keystore\n   */\n  async getKeystore() {\n    const user = await this._DBOperator.userDao.findUser();\n\n    return user.keystore;\n  }\n\n  /**\n   * delete keystore\n   * @returns {Boolean}\n   */\n  async deleteUser() {\n    const user = await this._DBOperator.userDao.findUser();\n    const item = await this._DBOperator.userDao.deleteUser(user);\n\n    if (item < 0) return false;\n\n    // await this._prefManager.clearAll();\n    return true;\n  }\n\n  mnemonicToSeed(mnemonic, password) {\n    const m = new Mnemonic();\n    return m.mnemonicToSeed(mnemonic, password);\n  }\n}\n\nmodule.exports = User;\n","const IndexedDB = require(\"./indexedDB\");\nconst { isBrowser } = require(\"../helpers/env\");\n\nclass DBOperator {\n  static instance;\n  database = null;\n  _isInit = false;\n\n  get userDao() {\n    return this.database.userDao;\n  }\n\n  get accountDao() {\n    return this.database.accountDao;\n  }\n\n  get currencyDao() {\n    return this.database.currencyDao;\n  }\n\n  get transactionDao() {\n    return this.database.transactionDao;\n  }\n\n  get networkDao() {\n    return this.database.networkDao;\n  }\n\n  get accountCurrencyDao() {\n    return this.database.accountCurrencyDao;\n  }\n\n  get utxoDao() {\n    return this.database.utxoDao;\n  }\n\n  get exchangeRateDao() {\n    return this.database.exchangeRateDao;\n  }\n\n  get prefDao() {\n    return this.database.prefDao;\n  }\n\n  constructor() {\n    if (!DBOperator.instance) {\n      DBOperator.instance = this;\n    }\n\n    return DBOperator.instance;\n  }\n\n  async init(inMemory = false) {\n    if (this._isInit) return;\n    this.database = isBrowser() ? new IndexedDB() : null;\n    this._isInit = true;\n\n    return this.database.init();\n  }\n\n  down() {\n    if (!this.database) return;\n    this.database.close();\n  }\n}\n\nmodule.exports = DBOperator;\n","const DB_NAME = \"tidebitwallet\";\nconst DB_VERSION = 1;\n\nconst OBJ_ACCOUNT = \"account\";\nconst OBJ_TX = \"transaction\";\nconst OBJ_UTXO = \"utxo\";\nconst OBJ_USER = \"user\";\nconst OBJ_CURRENCY = \"currency\";\nconst OBJ_NETWORK = \"network\";\nconst OBJ_ACCOUNT_CURRENCY = \"accountcurrency\";\nconst OBJ_EXCHANGE_RATE = \"exchange_rate\";\n\nconst OBJ_PREF = \"pref\";\n\n// primary key ?\nfunction _uuid() {\n  var d = Date.now();\n  if (\n    typeof performance !== \"undefined\" &&\n    typeof performance.now === \"function\"\n  ) {\n    d += performance.now();\n  }\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, function (c) {\n    var r = (d + Math.random() * 16) % 16 | 0;\n    d = Math.floor(d / 16);\n    return (c === \"x\" ? r : (r & 0x3) | 0x8).toString(16);\n  });\n}\n\nclass IndexedDB {\n  constructor() {}\n  db = null;\n  _userDao = null;\n  _accountDao = null;\n  _currencyDao = null;\n  _networkDao = null;\n  _txDao = null;\n  _accountcurrencyDao = null;\n  _utxoDao = null;\n  _exchangeRateDao = null;\n  _prefDao = null;\n\n  init() {\n    return this._createDB();\n  }\n\n  _createDB(dbName = DB_NAME, dbVersion = DB_VERSION) {\n    const request = indexedDB.open(dbName, dbVersion);\n\n    return new Promise((resolve, reject) => {\n      //on upgrade needed\n      request.onupgradeneeded = (e) => {\n        this.db = e.target.result;\n        this._createTable(dbVersion);\n      };\n\n      request.onsuccess = (e) => {\n        this.db = e.target.result;\n\n        this._userDao = new UserDao(this.db, OBJ_USER);\n        this._accountDao = new AccountDao(this.db, OBJ_ACCOUNT);\n        this._currencyDao = new CurrencyDao(this.db, OBJ_CURRENCY);\n        this._networkDao = new NetworkDao(this.db, OBJ_NETWORK);\n        this._txDao = new TransactionDao(this.db, OBJ_TX);\n        this._utxoDao = new UtxoDao(this.db, OBJ_UTXO);\n        this._accountcurrencyDao = new AccountCurrencyDao(\n          this.db,\n          OBJ_ACCOUNT_CURRENCY\n        );\n        this._exchangeRateDao = new ExchangeRateDao(this.db, OBJ_EXCHANGE_RATE);\n        this._prefDao = new PrefDao(this.db, OBJ_PREF);\n\n        resolve(this.db);\n      };\n\n      request.onerror = (e) => {\n        reject(this.db);\n      };\n    });\n  }\n\n  _createTable(version) {\n    if (version <= 1) {\n      const accounts = this.db.createObjectStore(OBJ_ACCOUNT, {\n        keyPath: \"accountId\",\n      });\n\n      const txs = this.db.createObjectStore(OBJ_TX, {\n        keyPath: \"transactionId\",\n      });\n      let txIndex = txs.createIndex(\"accountcurrencyId\", \"accountcurrencyId\");\n\n      const currency = this.db.createObjectStore(OBJ_CURRENCY, {\n        keyPath: \"currencyId\",\n      });\n      let currencyIndex = currency.createIndex(\"accountId\", \"accountId\");\n\n      const user = this.db.createObjectStore(OBJ_USER, {\n        keyPath: \"userId\",\n      });\n\n      const network = this.db.createObjectStore(OBJ_NETWORK, {\n        keyPath: \"networkId\",\n      });\n\n      const utxo = this.db.createObjectStore(OBJ_UTXO, {\n        keyPath: \"utxoId\",\n      });\n\n      const accountcurrency = this.db.createObjectStore(OBJ_ACCOUNT_CURRENCY, {\n        keyPath: \"accountcurrencyId\",\n      });\n      let accountcurrencyIndex = accountcurrency.createIndex(\n        \"accountId\",\n        \"accountId\"\n      );\n\n      const rate = this.db.createObjectStore(OBJ_EXCHANGE_RATE, {\n        keyPath: \"exchangeRateId\",\n      });\n\n      const pref = this.db.createObjectStore(OBJ_PREF, {\n        keyPath: \"prefId\",\n      });\n    }\n  }\n\n  close() {\n    this.db.close();\n  }\n\n  get userDao() {\n    return this._userDao;\n  }\n\n  get accountDao() {\n    return this._accountDao;\n  }\n\n  get currencyDao() {\n    return this._currencyDao;\n  }\n\n  get accountCurrencyDao() {\n    return this._accountcurrencyDao;\n  }\n\n  get networkDao() {\n    return this._networkDao;\n  }\n\n  get exchangeRateDao() {\n    return this._exchangeRateDao;\n  }\n\n  get transactionDao() {\n    return this._txDao;\n  }\n\n  get utxo() {\n    // TODO:\n    return this._utxoDao;\n  }\n\n  get prefDao() {\n    return this._prefDao;\n  }\n}\n\nclass DAO {\n  constructor(db, name) {\n    this._db = db;\n    this._name = name;\n  }\n\n  entity() {}\n\n  /**\n   *\n   * @param {Object} data The entity return value\n   * @param {Object} [options]\n   */\n  _write(data, options) {\n    return new Promise((resolve, reject) => {\n      const tx = this._db.transaction(this._name, \"readwrite\");\n      // const request = tx.objectStore(this._name).add(data);\n      const request = tx.objectStore(this._name).put(data);\n\n      request.onsuccess = (e) => {\n        resolve(true);\n      };\n\n      request.onerror = (e) => {\n        console.log(\"Write DB Error: \" + e.error);\n        reject(false);\n      };\n\n      tx.onabort = () => {\n        console.log(\"Write DB Error: Transaction Abort\");\n\n        reject(false);\n      };\n    });\n  }\n\n  _writeAll(entities) {\n    return new Promise((resolve, reject) => {\n      const tx = this._db.transaction(this._name, \"readwrite\");\n      entities.forEach((entity) => {\n        tx.objectStore(this._name).put(entity);\n      });\n\n      tx.oncomplete = (e) => {\n        resolve(true);\n      };\n\n      tx.onabort = (e) => {\n        reject(false);\n      };\n    });\n  }\n\n  _read(value = null, index) {\n    return new Promise((resolve, reject) => {\n      const tx = this._db.transaction(this._name, \"readonly\");\n      const store = tx.objectStore(this._name);\n\n      if (index) {\n        store = store.index(index);\n      }\n\n      let request;\n\n      if (!value) {\n        request = store.openCursor();\n        request.onsuccess = (e) => {\n          if (e.target.result) {\n            resolve(e.target.result.value);\n          } else {\n            resolve(null);\n          }\n        };\n      } else {\n        request = store.get(value);\n        request.onsuccess = (e) => {\n          resolve(e.target.result);\n        };\n      }\n\n      request.onerror = (e) => {\n        console.log(\"Read DB Error: \" + e.error);\n        reject(e.error);\n      };\n    });\n  }\n\n  _readAll(value = null, index) {\n    return new Promise((resolve, reject) => {\n      const tx = this._db.transaction(this._name, \"readonly\");\n      let store = tx.objectStore(this._name);\n\n      if (index) {\n        store = store.index(index);\n      }\n\n      const request = store.getAll(value);\n\n      request.onsuccess = (e) => {\n        resolve(e.target.result);\n      };\n\n      request.onerror = (e) => {\n        console.log(\"Read DB Error: \" + e.error);\n\n        reject(e.error);\n      };\n    });\n  }\n\n  _update() {\n    return new Promise((resolve, reject) => {\n      const tx = this._db.transaction(this._name, \"readwrite\");\n      const request = tx.objectStore(this._name).put(data);\n\n      request.onsuccess = (e) => {\n        resolve(true);\n      };\n\n      request.onerror = (e) => {\n        console.log(\"Update DB Error: \" + e.error);\n        reject(false);\n      };\n\n      tx.onabort = () => {\n        console.log(\"Update DB Error: Transaction Abort\");\n\n        reject(false);\n      };\n    });\n  }\n\n  _delete(key) {\n    return new Promise((resolve, reject) => {\n      let store = this._db\n        .transaction(this._name, \"readwrite\")\n        .objectStore(this._name);\n\n      const request = store.delete(key);\n\n      request.onsuccess = (e) => {\n        resolve(true);\n      };\n\n      request.onerror = (e) => {\n        reject(false);\n      };\n    });\n  }\n\n  _deleteAll() {\n    let store = this._db\n      .transaction(this._name, \"readwrite\")\n      .objectStore(this._name);\n    store.clear();\n  }\n}\n\nclass UserDao extends DAO {\n  constructor(db, name) {\n    super(db, name);\n  }\n\n  /**\n   * @override\n   */\n  entity({\n    user_id,\n    third_party_id,\n    install_id,\n    timestamp,\n    backup_status,\n    keystore,\n  }) {\n    return {\n      userId: user_id,\n      keystore,\n      thirdPartyId: third_party_id,\n      installId: install_id,\n      timestamp,\n      backupStatus: backup_status,\n      keystore,\n    };\n  }\n\n  findUser() {\n    return this._read();\n  }\n\n  insertUser(userEntity) {\n    return this._write(userEntity);\n  }\n\n  updateUser(userEntity) {\n    return this._write(userEntity);\n  }\n\n  deleteUser() {\n    return this._delete(1);\n  }\n}\n\nclass AccountDao extends DAO {\n  constructor(db, name) {\n    super(db, name);\n  }\n\n  /**\n   * @override\n   */\n  entity({ account_id, user_id, network_id, account_index }) {\n    return {\n      accountId: account_id,\n      userId: user_id,\n      networkId: network_id,\n      accountIndex: account_index,\n    };\n  }\n\n  findAllAccounts() {\n    return this._readAll();\n  }\n\n  findAccount(accountId) {\n    return this._read(accountId);\n  }\n\n  insertAccount(accountEntiry) {\n    return this._write(accountEntiry);\n  }\n\n  insertAccounts(accounts) {\n    return this._writeAll(accounts);\n  }\n}\n\nclass CurrencyDao extends DAO {\n  /**\n   * @override\n   */\n  entity({\n    currency_id,\n    name,\n    description,\n    symbol,\n    decimals,\n    // address,\n    total_supply,\n    contract,\n    type,\n    icon,\n  }) {\n    const _type = type === 0 ? \"fiat\" : type === 1 ? \"currency\" : \"token\";\n\n    return {\n      currencyId: currency_id,\n      name,\n      description,\n      symbol,\n      decimals,\n      address: contract,\n      totalSupply: total_supply,\n      contract,\n      type: _type,\n      image: icon,\n    };\n  }\n  constructor(db, name) {\n    super(db, name);\n  }\n\n  insertCurrency(currencyEntity) {\n    return this._write(currencyEntity);\n  }\n\n  insertCurrencies(currencies) {\n    return this._writeAll(currencies);\n  }\n\n  findAllCurrencies() {\n    return this._readAll();\n  }\n\n  findAllCurrenciesByAccountId(accountId) {\n    return this._readAll(accountId, \"accountId\");\n  }\n}\n\nclass NetworkDao extends DAO {\n  /**\n   * @override\n   */\n  entity({ network_id, network, coin_type, publish, chain_id }) {\n    return {\n      networkId: network_id,\n      network,\n      coinType: coin_type,\n      publish,\n      chainId: chain_id,\n    };\n  }\n  constructor(db, name) {\n    super(db, name);\n  }\n\n  findAllNetworks() {\n    return this._readAll();\n  }\n  insertNetworks(networks) {\n    return this._writeAll(networks);\n  }\n}\n\nclass TransactionDao extends DAO {\n  /**\n   * @override\n   */\n  entity({\n    accountcurrencyId,\n    txid,\n    confirmations,\n    source_addresses,\n    destination_addresses,\n    gas_price,\n    gas_limit,\n    note,\n    fee,\n    status,\n    timestamp,\n    direction,\n    amount,\n  }) {\n    return {\n      transactionId: accountcurrencyId + txid,\n      accountcurrencyId: accountcurrencyId,\n      txId: txid,\n      confirmation: confirmations,\n      sourceAddress: source_addresses,\n      destinctionAddress: destination_addresses,\n      gasPrice: gas_price,\n      gasUsed: gas_limit,\n      note,\n      fee,\n      status,\n      timestamp,\n      direction,\n      amount,\n    };\n  }\n\n  findAllTransactionsById(acId) {\n    return this._readAll(acId, \"accountcurrencyId\");\n  }\n\n  insertTransaction(entity) {\n    return this._write(entity);\n  }\n\n  updateTransaction(entity) {\n    return this._update(entity);\n  }\n  insertTransactions(txs) {\n    return this._writeAll(txs);\n  }\n}\n\nclass AccountCurrencyDao extends DAO {\n  entity({\n    // accountcurrency_id,\n    account_id,\n    currency_id,\n    balance,\n    number_of_used_external_key,\n    number_of_used_internal_key,\n    last_sync_time,\n    token_id,\n    account_token_id,\n    image,\n    symbol\n  }) {\n    return {\n      accountcurrencyId: account_token_id ?? account_id,\n      accountId: account_id,\n      currencyId: currency_id ?? token_id,\n      balance,\n      numberOfUsedExternalKey: number_of_used_external_key,\n      numberOfUsedInternalKey: number_of_used_internal_key,\n      lastSyncTime: last_sync_time,\n      image,\n      symbol\n    };\n  }\n  constructor(db, name) {\n    super(db, name);\n  }\n\n  findOneByAccountyId(id) {\n    return this._read(id);\n  }\n\n  findAllCurrencies() {\n    return this._readAll();\n  }\n\n  findJoinedByAccountId(accountId) {\n    return this._readAll(accountId, \"accountId\");\n  }\n\n  insertAccount(entity) {\n    return this._write(entity);\n  }\n\n  insertCurrencies(currencies) {\n    return this._writeAll(currencies);\n  }\n}\n\nclass ExchangeRateDao extends DAO {\n  entity({ currency_id, name, rate, timestamp, type }) {\n    return {\n      exchangeRateId: currency_id,\n      name,\n      rate,\n      lastSyncTime: timestamp,\n      type,\n    };\n  }\n  constructor(db, name) {\n    super(db, name);\n  }\n\n  insertExchangeRates(rates) {\n    return this._writeAll(rates);\n  }\n\n  findAllExchageRates() {\n    return this._readAll();\n  }\n}\n\nclass UtxoDao extends DAO {\n  constructor(db, name) {\n    super(db, name);\n  }\n}\n\nclass PrefDao extends DAO {\n  static AUTH_ITEM_KEY = 1;\n  static SELECTED_FIAT_KEY = 2;\n\n  entity({ token, tokenSecret }) {\n    return {\n      prefId: PrefDao.AUTH_ITEM_KEY,\n      token,\n      tokenSecret,\n    };\n  }\n  constructor(db, name) {\n    super(db, name);\n  }\n\n  async getAuthItem() {\n    const result = await this._read(PrefDao.AUTH_ITEM_KEY);\n\n    return result;\n  }\n\n  setAuthItem(token, tokenSecret) {\n    return this._write({\n      prefId: PrefDao.AUTH_ITEM_KEY,\n      token,\n      tokenSecret,\n    });\n  }\n\n  async getSelectedFiat() {\n    const result = await this._read(PrefDao.SELECTED_FIAT_KEY);\n\n    return result;\n  }\n\n  setSelectedFiat(name) {\n    return this._write({\n      prefId: PrefDao.SELECTED_FIAT_KEY,\n      name,\n    });\n  }\n}\n\n// *************************************************** //\n// if only use on browser, comment out this line\n// *************************************************** //\nmodule.exports = IndexedDB;\n\n// *************************************************** //\n// If not only using on browser, comment out this line\n// *************************************************** //\n// window.IndexedDB = IndexedDB;\n","const { utils } = require(\"web3\");\nconst EthUtils = require('ethereumjs-util');\nconst { BN } = EthUtils;\n\n// ++ use native functions\n\nclass Cryptor {\n  static keccak256round(str, round = 2) {\n    let result = str.replace('0x', '');\n\n    if (round > 0) {\n      result = utils.sha3('0x' + result);\n      return Cryptor.keccak256round(result, round - 1);\n    }\n\n    return result;\n  }\n\n  static randomBytes(length) {\n    let hexStr = '';\n    if (length > 0) {\n      hexStr = utils.randomHex(length).substr(2);\n    }\n    return Buffer.from(hexStr, 'hex');\n  }\n\n  static pathParse(keyPath) {\n    if (typeof keyPath !== 'string') throw new Error('keyPath should be string');\n    // keyPath = \"m/84'/3324'/0'/0/0\"\n\n    const arr = keyPath.split('/');\n    const chainIndex = arr[4];\n    const keyIndex = arr[5];\n    const options = {\n      path: `${arr[0]}/${arr[1]}/${arr[2]}`,\n    }\n    return { chainIndex, keyIndex, options };\n  }\n}\n\nmodule.exports = Cryptor;\n","const bip39 = require(\"bip39\");\n\nclass Mnemonic {\n  /**\n   * @method checkMnemonicVaildity\n   * @param {string} mnemonic\n   * @returns {boolean} valid\n   */\n  checkMnemonicVaildity(mnemonic) {\n    return bip39.validateMnemonic(mnemonic);\n  }\n\n  /**\n   * @method mnemonicToSeed\n   * @param {string} mnemonic\n   * @param {string} password\n   * @returns {Buffer} seed\n   */\n  mnemonicToSeed(mnemonic, password) {\n    const seed = bip39.mnemonicToSeedSync(mnemonic, password);\n    return seed;\n  }\n}\n\nmodule.exports = Mnemonic;\n","var isBrowser = function () {\n  try {\n    return this === window;\n  } catch (e) {\n    return false;\n  }\n};\n\nmodule.exports = {\n  isBrowser\n};\n","const rlp = require(\"rlp\");\n\n/**\n * Checks if the given string is an address\n *\n * @method isAddress\n * @param {String} address the given HEX adress\n * @return {Boolean}\n */\nvar isAddress = function (address) {\n  if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {\n    // check if it has the basic requirements of an address\n    return false;\n  } else if (\n    /^(0x)?[0-9a-f]{40}$/.test(address) ||\n    /^(0x)?[0-9A-F]{40}$/.test(address)\n  ) {\n    // If it's all small caps or all all caps, return true\n    return true;\n  } else {\n    // Otherwise check each case\n    return isChecksumAddress(address);\n  }\n};\n\n/**\n * Checks if the given string is a checksummed address\n *\n * @method isChecksumAddress\n * @param {String} address the given HEX adress\n * @return {Boolean}\n */\nvar isChecksumAddress = function (address) {\n  // Check each case\n  address = address.replace(\"0x\", \"\");\n  var addressHash = sha3(address.toLowerCase());\n  for (var i = 0; i < 40; i++) {\n    // the nth letter should be uppercase if the nth digit of casemap is 1\n    if (\n      (parseInt(addressHash[i], 16) > 7 &&\n        address[i].toUpperCase() !== address[i]) ||\n      (parseInt(addressHash[i], 16) <= 7 &&\n        address[i].toLowerCase() !== address[i])\n    ) {\n      return false;\n    }\n  }\n  return true;\n};\n\nfunction verifyEthereumAddress(address) {\n  if (address.contains(\":\")) {\n    address = address.split(\":\")[1];\n  }\n\n  return isAddress(address);\n}\n\n/**\n * RLP encode ETH Transation\n * @method encodeToRlp\n * @param {ETHTransaction} transaction The ETHTransaction\n * @returns {Buffer} rlp\n */\nfunction encodeToRlp(transaction) {\n  const list = [\n    Buffer.from(transaction.nonce.toString(16)),\n    transaction.gasPrice.toString(16),\n    transaction.gasUsed.toString(16),\n  ].map((v) => `0x${v}`);\n\n  if (transaction.to) {\n    list.push(transaction.to);\n  } else {\n    list.push(\"\");\n  }\n\n  list.push(`0x${transaction.amount.toString(16)}`);\n\n  if (transaction.message) {\n    list.push(transaction.message);\n  } else {\n    list.push(\"\");\n  }\n\n  if (transaction.signature) {\n    list.push(transaction.signature.v);\n    list.push(transaction.signature.r.toNumber());\n    list.push(transaction.signature.s.toNumber());\n  }\n\n  return rlp.encode(list);\n}\n\nfunction getEthereumAddressBytes(address) {\n  return Buffer.from(address, \"hex\");\n}\n\nmodule.exports = {\n  encodeToRlp,\n  verifyEthereumAddress,\n  getEthereumAddressBytes,\n};\n","const axios = require(\"axios\");\nconst { url } = require(\"../constants/config\");\nclass HTTPAgent {\n  static instance;\n\n  constructor({ apiURL = '' } = {}) {\n    this.url = apiURL || url\n    if (!HTTPAgent.instance) {\n      this.axios = axios.create({\n        baseURL: this.url,\n      });\n      HTTPAgent.instance = this;\n    }\n    return HTTPAgent.instance;\n  }\n\n  setInterceptor() {\n    // TODO: retry, logger?\n  }\n\n  setToken(token) {\n    this.axios.defaults.headers.common[\"token\"] = token;\n  }\n\n  getToken() {\n    try {\n      const { token } = this.axios.defaults.headers.common\n      return token || null\n    } catch (e) {\n      return null\n    }\n  }\n\n  _request(request) {\n    return request().then((res) => {\n      if (!res.data) {\n        return {\n          success: fasle,\n        };\n      }\n\n      return {\n        success: res.data.success,\n        data: res.data.payload,\n        message: res.data.message,\n        code: res.data.code,\n      };\n    });\n  }\n\n  get(path) {\n    return this._request(() => this.axios.get(path));\n  }\n\n  post(path, body) {\n    return this._request(() => this.axios.post(path, body));\n  }\n\n  delete(path, body) {\n    return this._request(() => this.axios.delete(path, body));\n  }\n\n  put(path, body) {\n    return this._request(() => this.axios.put(path, body));\n  }\n\n  _refreshToken() {\n    //TODO:\n  }\n}\n\nmodule.exports = HTTPAgent;\n","class rlp {\n  static isHexString(value) {\n    if (!value) return false;\n  \n    return /^0x[0-9A-Fa-f]*/.test(value)\n  }\n  static intToHex(int) {\n    if (int < 0) {\n      throw new Error('Invalid integer as argument, must be unsigned!')\n    }\n    const hex = int.toString(16)\n    return hex.length % 2 ? `0${hex}` : hex\n  }\n  static intToBuffer(int) {\n    const hex = rlp.intToHex(int)\n    return Buffer.from(hex, 'hex')\n  }\n  static intToBuffer(int) {\n    const hex = rlp.intToHex(int)\n    return Buffer.from(hex, 'hex')\n  }\n  static toBuffer(data) {\n    if (data === null) return Buffer.from(0)\n    if (Buffer.isBuffer(data)) return data\n\n    if (typeof data === 'string') {\n      if (rlp.isHexString(data)) {\n        return Buffer.from(data, 'hex')\n      } else {\n        return Buffer.from(data, 'utf8')\n      }\n    } else if (typeof data === 'number') {\n      if (data === 0) return Buffer.from(0)\n      return rlp.intToBuffer(data)\n    // } else if (data is BigInt) {\n    //   if (data == BigInt.zero) return Uint8List(0);\n    //   return Uint8List.fromList(encodeBigInt(data));\n    } else if (Array.isArray(data)) {\n      return Buffer.from(data)\n    }\n  }\n}\n\nmodule.exports = rlp \n","const BigNumber = require('bignumber.js');\nconst config = require(\"./constants/config\");\nconst PaperWallet = require(\"./cores/PaperWallet\");\nconst Account = require(\"./cores/Account\");\nconst Trader = require(\"./cores/Trader\");\nconst User = require(\"./cores/User\");\nconst { isBrowser } = require(\"./helpers/env\");\nconst DBOperator = require(\"./database/dbOperator\");\nconst TideWalletCommunicator = require(\"./cores/TideWalletCommunicator\");\nconst TideWalletCore = require(\"./cores/TideWalletCore\");\nconst packageInfo = require(\"../package.json\");\n\nclass TideWallet {\n  // eventType: ready, update, notice\n  // notifier: { eventName: string, callback: function }\n  notifiers = [];\n\n  static Core = TideWalletCore;\n\n  constructor() {\n    return this;\n  }\n\n  async init({ user, api }) {\n    const communicator = new TideWalletCommunicator(api);\n    const db = new DBOperator();\n    await db.init();\n    const initObj = { TideWalletCommunicator: communicator, DBOperator: db };\n\n    this.user = new User(initObj);\n\n    const exist = await this.user.checkUser();\n    if (!exist) {\n      if(user.mnemonic && user.password) {\n        this.core = await this.user.createUserWithSeed(user.OAuthID, seed, user.InstallID);\n      } else {\n        this.core = await this.user.createUser(user.OAuthID, user.InstallID);\n      }\n    }\n  \n    initObj.TideWalletCore = this.core;\n    this.account = new Account(initObj);\n    this.account.setMessenger();\n    await this.account.init();\n\n    this.trader = new Trader(initObj);\n    await this.trader.getFiatList();\n  \n    const listener = this.account.messenger.subscribe((v) => {\n      this.notice(v, 'update');\n    });\n    return true;\n  }\n\n  on(eventName = '', callback) {\n    if(typeof callback !== 'function') return;\n    const en = eventName.toLocaleLowerCase();\n    let notifier = { callback };\n    switch(en) {\n      case 'ready':\n      case 'update':\n      case 'notice':\n        notifier.eventName = en;\n        break;\n    }\n    return this.notifiers.push(notifier);\n  }\n\n  removeNotifier(notifierId) {\n    delete this.notifiers[notifierId];\n    return true;\n  }\n\n  async getWalletConfig() {\n    const fiat = await this.trader.getSelectedFiat();\n    const version = packageInfo.version;\n    return { fiat, version };\n  }\n\n  async overview() {\n    const currencies = await this.account.getAllCurrencies();\n    const fiat = await this.trader.getSelectedFiat();\n    const bnRate = fiat.exchangeRate;\n    const balance = currencies.reduce((rs, curr) => {\n      const bnBalance = new BigNumber(curr.balance);\n      const bnRs = new BigNumber(rs);\n      return bnRs.plus(\n        this.trader.calculateToUSD({ currencyId: curr.currencyId, amount: bnBalance }))\n        .toFixed();\n    }, 0);\n    const bnBalance = new BigNumber(balance);\n    const balanceFiat = bnBalance.multipliedBy(bnRate).toFixed();\n\n    const dashboard = {\n      balance: balanceFiat,\n      currencies\n    };\n    return dashboard;\n  }\n\n  /**\n   * \n   * @param {object} accountInfo\n   * @param {string} accountInfo.assetID\n   */\n  async getAssetDetail({ assetID }) {\n    const asset = await this.account.getCurrencies(assetID);\n    const transactions = await this.account.getTransactions(assetID);\n    \n    return { asset, transactions };\n  }\n\n  async getTransactionDetail({ assetID, transactionID }) {\n    const txs = await this.account.getTransactions(assetID);\n    const tx = txs.find((r) => r.txId === transactionID );\n    return tx;\n  }\n\n  async getReceivingAddress({ accountID }) {\n    const address = await this.account.getReceiveAddress(accountID);\n\n    return address;\n  }\n\n  // ++ need help\n  async getTransactionFee({ accountID, blockchainID, from, to, amount, data }) {\n    const svc = this.account.getService(accountID);\n    const fees = svc.getTransactionFee(blockchainID);\n\n    return fees;\n  }\n\n  // need help\n  async prepareTransaction() {\n\n  }\n\n  async sendTransaction({ accountID, blockchainID, transaction }) {\n      const svc = this.account.getService(accountID);\n      const res = svc.publishTransaction(blockchainID, transaction);\n\n      return res;\n  }\n\n  async sync() {\n    this.account.sync();\n    return true;\n  }\n\n  async backup() {\n    return this.user.getKeystore();\n  }\n\n  async close() {\n    // release all resources\n    this.account.close();\n    for(const index in this.notifiers) {\n      this.removeNotifier(index);\n    }\n    delete this.user;\n    delete this.account;\n    delete this.trader\n    return true;\n  }\n\n  notice(data, eventName = '') {\n    const ev = eventName.toLocaleLowerCase();\n    this.notifiers.forEach((notifier) => {\n      if(!notifier) return;\n      if(notifier.eventName !== ev) return;\n      if(typeof notifier.callback !== 'function') return;\n      notifier.callback(data);\n    });\n  }\n}\n\nif (isBrowser()) {\n  window.Buffer = require(\"buffer\").Buffer;\n  window.TideWallet = TideWallet;\n\n  /** test case */\n  window.test = async() => {\n    const tw = new TideWallet();\n    const api = {\n      apiURL: 'https://service.tidewallet.io/api/v1',\n      apiKey: 'f2a76e8431b02f263a0e1a0c34a70466',\n      apiSecret: '9e37d67450dc906042fde75113ecb78c',\n    };\n    const user1 = {\n      OAuthID: 'test2ejknkjdniednwjq',\n      InstallID: '11f6d3e524f367952cb838bf7ef24e0cfb5865d7b8a8fe5c699f748b2fada249',\n      mnemonic: 'cry hub inmate cliff sun program public else atom absurd release inherit funny edge assault',\n      password: '12345'\n    };\n    const user2 = {\n      OAuthID: 'test2ejknkjdniednwjq',\n      InstallID: '11f6d3e524f367952cb838bf7ef24e0cfb5865d7b8a8fe5c699f748b2fada249'\n    };\n    await tw.init({ user: user2, api });\n    //test\n    // console.log('overview:', await tw.overview());\n    // console.log('getAssetDetail:', await tw.getAssetDetail({ assetID: \"a7255d05-eacf-4278-9139-0cfceb9abed6\" }));\n    // console.log('getTransactionDetail:', await tw.getTransactionDetail({ assetID: \"a7255d05-eacf-4278-9139-0cfceb9abed6\", transactionID:\"\" }));\n    // console.log('getReceivingAddress:', await tw.getReceivingAddress({ accountID: \"a7255d05-eacf-4278-9139-0cfceb9abed6\" }));\n    // console.log('getWalletConfig:', await tw.getWalletConfig());\n    // await tw.sync();\n    // console.log('backup:', await tw.backup());\n    // await tw.close();\n  }\n}\n\nmodule.exports = TideWallet;\n","const ACCOUNT_EVT = {\n  OnUpdateAccount: \"OnUpdateAccount\",\n  OnUpdateCurrency: \"OnUpdateCurrency\",\n  OnUpdateTransactions: \"OnUpdateTransactions\",\n  OnUpdateTransaction: \"OnUpdateTransaction\",\n  ClearAll: \"ClearAll\",\n  ToggleDisplayCurrency: \"ToggleDisplayCurrency\",\n};\n\nconst ACCOUNT = {\n  ETH: 'ETH',\n  BTC: 'BTC',\n  CFC: 'CFC'\n}\n\nmodule.exports = {\n  ACCOUNT_EVT,\n  ACCOUNT\n};\n","/**\n * @abstract\n * @property {string} id                    The transaction id\n * @property {string} direction             The direction\n * @property {BigNumber} amount             The amount\n * @property {string} status                The transaction status\n * @property {number} confirmations         The confirmations number\n * @property {string} address               The address is to or from address depending on direction\n * @property {BigNumber} fee                The fee\n * @property {string} txId                  The txId from API\n * @property {string} message               The transaction message\n * @property {string} sourceAddresses       The source addresses\n * @property {string} destinationAddresses  The destination addresses\n * @property {BigNumber} gasPrice           The gas price\n * @property {BigNumber} gasUsed            The gase used/limit\n */\nclass Transaction {\n  id;\n  direction;\n  amount;\n  status;\n  timestamp;\n  confirmations;\n  address;\n  fee;\n  txId;\n  message;\n  sourceAddresses;\n  destinationAddresses;\n  gasPrice;\n  gasUsed;\n\n  constructor(values) {\n    Object.assign(this, values);\n  }\n\n  serializeTransaction() {}\n\n  static createTransaction() {}\n}\n\nconst TRANSACTION_STATUS = {\n  success: \"success\",\n  fail: \"fail\",\n  pending: \"pending\",\n};\n\nconst TRANSACTION_DIRECTION = {\n  sent: \"sent\",\n  received: \"received\",\n  moved: \"moved\",\n  unknown: \"unknown\",\n};\n\nconst TRANSACTION_PRIORITY = {\n  slow: \"slow\",\n  standard: \"standard\",\n  fast: \"fast\",\n};\n\n/**\n * @property {number} v\n * @property {BigNumber} r\n * @property {BigNumber} s\n */\nclass Signature {\n  constructor({ v, r, s }) {\n    this.v = v;\n    this.r = r;\n    this.s = s;\n  }\n}\n\nmodule.exports = {\n  Transaction,\n  TRANSACTION_STATUS,\n  TRANSACTION_DIRECTION,\n  TRANSACTION_PRIORITY,\n  Signature,\n};\n","const {\n  Transaction,\n  TRANSACTION_DIRECTION,\n  TRANSACTION_STATUS,\n  Signature,\n} = require(\"./tranasction.model\");\nconst { encodeToRlp } = require(\"../helpers/ethereumUtils\");\nconst BigNumber = require('bignumber.js');\n\nclass ETHTransaction extends Transaction {\n  nonce;\n  to;\n  signature;\n\n  constructor(values) {\n    super(values);\n    this.nonce = values.nonce;\n    this.to = values.to;\n    this.signature = values.signature;\n  }\n\n  serializeTransaction() {\n    return encodeToRlp(this);\n  }\n\n  static createTransaction({\n    from,\n    to,\n    amount,\n    gasPrice,\n    gasUsed,\n    message,\n    chainId,\n    fee,\n    nonce,\n  }) {\n    return new ETHTransaction({\n      amount,\n      gasPrice,\n      gasUsed,\n      message,\n      chainId,\n      direction: TRANSACTION_DIRECTION.sent,\n      status: TRANSACTION_STATUS.pending,\n      destinationAddresses: to,\n      sourceAddresses: from,\n      fee,\n      nonce,\n      to,\n      signature: new Signature({\n        v: chainId,\n        r: BigNumber(0),\n        s: BigNumber(0),\n      }),\n    });\n  }\n}\n\nmodule.exports = ETHTransaction;\n","/**\n @abstract\n**/\nclass AccountService {\n  _syncInterval = 60 * 10 * 1000;\n\n  _lastSyncTimestamp = 0;\n\n  _timer = null;\n  _base = null;\n  _accountId = null;\n\n  _AccountCore = null;\n\n  get accountId() {\n    return this._accountId;\n  }\n\n  set accountId(id) {\n    this._accountId = id;\n  }\n\n  get base() {\n    return this._base;\n  }\n\n  set base(base) {\n    this._base = base;\n  }\n\n  get timer() {\n    return this._timer;\n  }\n\n  set timer(timer) {\n    this._timer = timer;\n  }\n\n  get lastSyncTimestamp() {\n    return this._lastSyncTimestamp;\n  }\n\n  get AccountCore() {\n    return this._AccountCore;\n  }\n\n  init(accountId, base, interval) {}\n\n  start() {}\n\n  stop() {}\n\n  getReceivingAddress() {}\n\n  getChangingAddress() {}\n\n  getTransactionFee() {}\n\n  publishTransaction() {}\n\n  updateTransaction() {}\n\n  updateCurrency() {}\n\n  synchro() {}\n}\n\nmodule.exports = AccountService;\n","const { ACCOUNT_EVT } = require(\"../models/account.model\");\nconst AccountService = require(\"./accountService\");\nclass AccountServiceBase extends AccountService {\n  constructor(AccountCore) {\n    super();\n    this._AccountCore = AccountCore;\n    this._DBOperator = AccountCore._DBOperator;\n    this._TideWalletCommunicator = AccountCore._TideWalletCommunicator;\n  }\n\n  /**\n   * Push subject event to AccountCore messenger\n   * @method _pushResult\n   * @returns {void}\n   */\n  async _pushResult() {\n    let cs = await this._DBOperator.accountCurrencyDao.findJoinedByAccountId(\n      this._accountId\n    );\n\n    cs = cs.map((c) => ({\n      ...c,\n      accountType: this._base,\n    }));\n\n    this._AccountCore.currencies[this._accountId] = cs;\n\n    const msg = {\n      evt: ACCOUNT_EVT.OnUpdateCurrency,\n      value: cs,\n    };\n\n    this._AccountCore.messenger.next(msg);\n  }\n\n  /**\n   * Get currencies including account and tokens\n   * If tokens not store in databse, would fetch the token detail and insert to database\n   * @method _getData\n   * @returns {Array} Concat of account and tokens array\n   */\n  async _getData() {\n    try {\n      const res = await this._TideWalletCommunicator.AccountDetail(this._accountId)\n      const acc = res;\n      const tokens = acc[\"tokens\"];\n      const currs = await this._DBOperator.currencyDao.findAllCurrencies();\n      const newTokens = [];\n\n      tokens.forEach((token) => {\n        const index = currs.findIndex(\n          (c) => c.currencyId === token[\"token_id\"]\n        );\n\n        if (index < 0) {\n          newTokens.push(cur);\n        }\n      });\n\n      if (newTokens.length > 0) {\n        await Promise.all(\n          newTokens.map((token) => {\n            return new Promise(async (resolve, reject) => {\n              const res = await this._TideWalletCommunicator.TokenDetail(token[\"blockchain_id\"], token[\"token_id\"]);\n              if (res != null) {\n                const token = this._DBOperator.currencyDao.entity(res);\n\n                await this._DBOperator.currencyDao.insertCurrency(token);\n              }\n            });\n          })\n        );\n      }\n\n      return [acc, ...tokens];\n    } catch (error) {\n      console.log(error);\n      return [];\n    }\n  }\n\n  /**\n   * If there is not any tokens, get tokens\n   * @method _getSupportedToken\n   * @returns {void}\n   */\n  async _getSupportedToken() {\n    const tokens =\n      await this._DBOperator.currencyDao.findAllCurrenciesByAccountId(\n        this._accountId\n      );\n\n    if (tokens.length < 1) {\n      const acc = await this._DBOperator.accountDao.findAccount(\n        this._accountId\n      );\n      try {\n        const res = await this._TideWalletCommunicator.TokenList(acc.networkId);\n        if (res) {\n          const tokens = res.map((t) =>\n            this._DBOperator.currencyDao.entity(t)\n          );\n          await this._DBOperator.currencyDao.insertCurrencies(tokens);\n        }\n      } catch (error) {\n        console.log(error);\n      }\n    }\n  }\n\n  /**\n   * Sync transctions belong this account\n   * And push subject event to AccountCore messenger\n   * @method _syncTransactions\n   * @returns {void}\n   */\n  async _syncTransactions() {\n    const currencies = this._AccountCore.currencies[this._accountId];\n    const qureries = currencies.map((currency) => {\n      return new Promise(async (resolve) => {\n        const transactions = await this._getTransaction(currency);\n        const txMsg = {\n          evt: ACCOUNT_EVT.OnUpdateTransactions,\n          value: {\n            currency,\n            transactions,\n          },\n        };\n\n        this._AccountCore.messenger.next(txMsg);\n\n        resolve(true);\n      });\n    });\n\n    qureries.reduce(\n      (promise, func) =>\n        promise.then((result) =>\n          func.then(Array.prototype.concat.bind(result))\n        ),\n      Promise.resolve([])\n    );\n  }\n\n  /**\n   * Get transctions\n   * @method _getTransaction\n   * @param {Object} currency The accountcurrency object\n   * @returns {Array} The sorted transactions\n   */\n  async _getTransaction(currency) {\n    try {\n      const res = await this._TideWalletCommunicator.ListTransactions(currency.accountcurrencyId);\n      const txs = res.map((t) =>\n        this._DBOperator.transactionDao.entity({\n          ...t,\n          accountcurrencyId: currency.accountcurrencyId,\n        })\n      );\n\n      await this._DBOperator.transactionDao.insertTransactions(txs);\n    } catch (error) {\n      console.log(error);\n    }\n\n    return this._loadTransactions(currency.id);\n  }\n\n  /**\n   * Load transctions from database\n   * @method _loadTransactions\n   * @param {string} currency The accountcurrency Id\n   * @returns {Array} The sorted transactions\n   */\n  async _loadTransactions(currencyId) {\n    const transactions =\n      await this._DBOperator.transactionDao.findAllTransactionsById(currencyId);\n\n    const txNull = transactions.filter((t) => t.timestamp === null);\n    const txReady = transactions.filter((t) => t.timestamp !== null);\n\n    return [...txNull, ...txReady];\n  }\n\n  /**\n   * Load setting page token list\n   * @method _getSettingTokens\n   * @returns {void}\n   */\n  async _getSettingTokens() {\n    const acc = await this._DBOperator.accountDao.findAccount(this._accountId);\n    try {\n      const res = await this._TideWalletCommunicator.TokenList(acc.networkId);\n      const ds = res.map((tk) => ({\n        ...tk,\n        accountId: this._accountId,\n        blockchainId: acc.networkId,\n      }));\n      this._AccountCore.settingOptions += ds;\n    } catch (error) {\n      console.log(error);\n    }\n  }\n\n  /**\n   * @override\n   */\n  init(accountId, base, interval) {\n    this._accountId = accountId;\n    this._base = base;\n    this._syncInterval = interval ?? this._syncInterval;\n  }\n\n  /**\n   * @override\n   */\n  async start() {\n    const select =\n      await this._DBOperator.accountCurrencyDao.findOneByAccountyId(\n        this._accountId\n      );\n\n    await this._pushResult();\n    await this._getSupportedToken();\n    await this._getSettingTokens();\n\n    if (select) {\n      this._lastSyncTimestamp = select.lastSyncTime;\n    } else {\n      this._lastSyncTimestamp = 0;\n    }\n  }\n\n  /**\n   * Clear timer\n   * @override\n   */\n  stop() {\n    clearInterval(this.timer);\n  }\n\n  /**\n   * @override\n   */\n  getReceivingAddress() {\n    // Override by decorator\n  }\n\n  /**\n   * @override\n   */\n  getChangingAddress() {\n    // Override by decorator\n  }\n\n  /**\n   * @override\n   */\n  getTransactionFee() {\n    // Override by decorator\n  }\n\n  /**\n   * @override\n   */\n  publishTransaction() {\n    // Override by decorator\n  }\n\n  /**\n   * Update transactions\n   * This function would be call by notification\n   * @override\n   * @method updateTransaction\n   * @param {string} currency The accountcurrency Id\n   * @param {Object} transaction The transaction\n   * @returns {void}\n   */\n  async updateTransaction(currencyId, transaction) {\n    const currencies = this._AccountCore.currencies[this.accountId];\n    const currency = currencies.find((c) => c.currencyId === currencyId);\n\n    const txMsg = {\n      currency,\n      transactions,\n    };\n\n    this._AccountCore.messenger.next(txMsg);\n\n    await this._DBOperator.transactionDao.insertTransaction(transaction);\n  }\n\n  /**\n   * Update currencies\n   * This function would be call by notification\n   * @override\n   * @method updateCurrency\n   * @param {string} currency The accountcurrency Id\n   * @param {Array} transactions The transaction list\n   * @returns {void}\n   */\n  async updateCurrency(currencyId, payload) {\n    const acs = await this._DBOperator.accountCurrencyDao.findAllCurrencies();\n    const ac = acs.find((a) => a.currencyId === currencyId);\n    const updated = this._DBOperator.accountCurrencyDao.entity({\n      accountcurrency_id: ac.accountcurrencyId,\n      account_id: this._accountId,\n      currency_id: ac.currencyId,\n      balance: `${payload[\"balance\"]}`,\n      number_of_used_external_key: ac.numberOfUsedExternalKey,\n      number_of_used_internal_key: ac.numberOfUsedInternalKey,\n      last_sync_time: Date.now(),\n    });\n\n    await this._DBOperator.accountCurrencyDao.insertAccount(updated);\n    this._pushResult();\n  }\n\n  /**\n   * Get currencies if needed\n   * @override\n   * @method synchro\n   * @param {boolean} force Force synchro\n   * @returns {void}\n   */\n  async synchro(force = false) {\n    const now = Date.now();\n\n    if (now - this._lastSyncTimestamp > this._syncInterval || force) {\n      const currs = await this._getData();\n      const v = currs.map((c) => this._DBOperator.accountCurrencyDao.entity({\n        ...c,\n        accountcurrency_id: c['account_id'] ?? c['account_token_id'],\n        account_id: this._accountId,\n        last_sync_time: now,\n        image: c['icon']\n      }));\n\n      await this._DBOperator.accountCurrencyDao.insertCurrencies(v);\n    }\n\n    await this._pushResult();\n    await this._syncTransactions();\n  }\n}\n\nmodule.exports = AccountServiceBase;\n","const AccountService = require(\"./accountService\");\n\n/**\n @abstract\n**/\nclass AccountServiceDecorator extends AccountService {\n  service = null;\n\n  get accountId() {\n      return this.service.accountId;\n  }\n\n  get base() {\n    return this.service.base;\n  }\n}\n\nmodule.exports = AccountServiceDecorator;\n","const AccountServiceDecorator = require(\"./accountServiceDecorator\");\nconst { ACCOUNT, ACCOUNT_EVT } = require(\"../models/account.model\");\n\nclass EthereumService extends AccountServiceDecorator {\n  constructor(service, TideWalletCommunicator, DBOperator) {\n    super();\n    this.service = service;\n    this._base = ACCOUNT.ETH;\n    this._syncInterval = 15000;\n\n    this._address = null;\n    this._fee = null;\n    this._gasLimit = null;\n    this._feeTimestamp = null;\n    this._nonce = 0;\n\n    this._TideWalletCommunicator = TideWalletCommunicator;\n    this._DBOperator = DBOperator;\n  }\n\n  /**\n    @override\n  **/\n  init(accountId, base, interval) {\n    this.service.init(\n      accountId,\n      base || this._base,\n      interval !== this._syncInterval ? interval : this._syncInterval\n    );\n  }\n\n  /**\n    @override\n  **/\n  async start() {\n    console.log(\n      this.base,\n      \" Service Start \",\n      this.accountId,\n      this._syncInterval\n    );\n\n    await this.service.start();\n\n    this.synchro();\n\n    this.service.timer = setInterval(() => {\n      this.synchro();\n    }, this._syncInterval);\n  }\n\n  /**\n    @override\n  **/\n  stop() {\n    this.service.stop();\n  }\n\n  /**\n   * getReceivingAddress\n   * @override\n   * @param {String} accountcurrencyId\n   * @returns {Array.<{address: String || error, code: Number}>} result\n   */\n  async getReceivingAddress(accountcurrencyId) {\n    if (this._address === null) {\n      try {\n        const response = await this._TideWalletCommunicator.AccountReceive(accountcurrencyId);\n        const address = response[\"address\"];\n        this._address = address;\n      } catch (error) {\n        console.log(error)\n        //TODO\n        return [\"error\", 0];\n      }\n    }\n    return [this._address, null];\n  }\n\n  /**\n   * getChangingAddress\n   * @override\n   * @param {String} currencyId\n   * @returns {{address: String || error, code: Number}[]} result\n   */\n  async getChangingAddress(currencyId) {\n    return await this.getReceivingAddress(currencyId);\n  }\n\n  /**\n   * getTransactionFee\n   * @override\n   * @param {String} blockchainId\n   * @returns {Object} result\n   * @returns {string} result.slow\n   * @returns {string} result.standard\n   * @returns {string} result.fast\n   */\n  async getTransactionFee(blockchainId) {\n    if (\n      this._fee == null ||\n      Date.now() - this._feeTimestamp > this.AVERAGE_FETCH_FEE_TIME\n    ) {\n      try {\n        const response = await this._TideWalletCommunicator.GetFee(blockchainId);\n        const { slow, standard, fast } = response;\n        this._fee = {\n          slow,\n          standard,\n          fast,\n        };\n        this._feeTimestamp = Date.now();\n      } catch (error) {\n        console.log(error)\n        // TODO fee = null 前面會出錯\n      }\n    }\n    return this._fee;\n  }\n\n  /**\n   * publishTransaction\n   * @override\n   * @param {String} blockchainId\n   * @param {Transaction} transaction\n   * @returns {Array.<{success: Boolean, transaction: String}>} result\n   */\n  async publishTransaction(blockchainId, transaction) {\n    try {\n      const body = {\n        hex:\n          \"0x\" + Buffer.from(transaction.serializeTransaction).toString(\"hex\"),\n      }\n      const response = await this._TideWalletCommunicator.PublishTransaction(blockchainId, body);\n      transaction.txId = response[\"txid\"];\n      transaction.timestamp = Date.now();\n      transaction.confirmations = 0;\n      return [true, transaction];\n    } catch (error) {\n      console.log(error);\n      return [false, transaction];\n    }\n  }\n\n  /**\n   * updateTransaction\n   * @override\n   * @param {String} currencyId\n   * @param {Object} payload\n   * @returns {Object} transaction table object\n   */\n  async updateTransaction(currencyId, payload) {\n    return await this.service.updateTransaction(currencyId, payload);\n  }\n\n  /**\n   * updateCurrency\n   * @override\n   * @param {String} currencyId\n   * @param {Object} payload\n   * @returns {Object} currency table object\n   */\n  async updateCurrency(currencyId, payload) {\n    return await this.service.updateCurrency(currencyId, payload);\n  }\n\n  /**\n   * @override\n   **/\n  synchro(force = false) {\n    this.service.synchro(force);\n  }\n\n  /**\n   * addToken\n   * @override\n   * @param {String} blockchainId\n   * @param {Object} token\n   * @returns {Boolean} result\n   */\n  async addToken(blockchainId, token) {\n    try {\n      const res = await this._TideWalletCommunicator.TokenRegist(blockchainId, token.contract);\n      const { token_id: id } = res;\n      const updateResult = await this._TideWalletCommunicator.AccountDetail(this.service.accountId);\n\n      const accountItem = updateResult;\n      const tokens = [accountItem, ...accountItem.tokens];\n      const index = tokens.findIndex((token) => token[\"token_id\"] == id);\n\n      const data = {\n        ...tokens[index],\n        icon: token.imgUrl || accountItem[\"icon\"],\n        currency_id: id,\n      };\n\n      const curr = this._DBOperator.currencyDao.entity({\n        ...data,\n      });\n      await this._DBOperator.currencyDao.insertCurrency(curr);\n\n      const now = Date.now();\n      const v = this._DBOperator.accountCurrencyDao.entity({\n        ...tokens[index],\n        account_id: this.service.accountId,\n        currency_id: id,\n        last_sync_time: now,\n      });\n\n      await this._DBOperator.accountCurrencyDao.insertAccount(v);\n\n      const findAccountCurrencies =\n        await this._DBOperator.accountCurrencyDao.findJoinedByAccountId(\n          this.service.accountId\n        );\n\n      // List<Currency> cs = findAccountCurrencies\n      //     .map((c) => Currency.fromJoinCurrency(c, jcs[0], this.base))\n      //     .toList();\n\n      // TODO: messenger\n      // const msg = AccountMessage(evt: ACCOUNT_EVT.OnUpdateAccount, value: cs[0]);\n      // this.service.AccountCore().currencies[this.service.accountId] = cs;\n\n      const currMsg = {\n        evt: ACCOUNT_EVT.OnUpdateCurrency,\n        value: this.service.AccountCore().currencies[this.service.accountId],\n      };\n\n      this.service.AccountCore().messenger.next(currMsg);\n\n      return true;\n    } catch (e) {\n      console.error(e);\n\n      return false;\n    }\n  }\n\n  /**\n   * estimateGasLimit\n   * @override\n   * @param {String} blockchainId\n   * @param {String} from\n   * @param {String} to\n   * @param {String} amount\n   * @param {String} message\n   * @returns {Boolean} result\n   */\n  async estimateGasLimit(blockchainId, from, to, amount, message) {\n    if (message == \"0x\" && this._gasLimit != null) {\n      return this._gasLimit;\n    } else {\n      const payload = {\n        fromAddress: from,\n        toAddress: to,\n        value: amount,\n        data: message,\n      };\n      try {\n        const response = await this._TideWalletCommunicator.GetGasLimit(blockchainId, payload);\n        this._gasLimit = Number(response.gasLimit);\n      } catch (error) {\n        // TODO\n        // _gasLimit = 21000;\n        throw error;\n      }\n      return this._gasLimit;\n    }\n  }\n\n  /**\n   * getNonce\n   * @override\n   * @param {String} blockchainId\n   * @param {String} address\n   * @returns {Number} nonce\n   */\n  async getNonce(blockchainId, address) {\n    try {\n      const response = await this._TideWalletCommunicator.GetNonce(blockchainId, address);\n      const nonce = Number(response[\"nonce\"]);\n      this._nonce = nonce;\n      return nonce;\n    } catch (error) {\n      console.log(error);\n      // TODO:\n      return (this._nonce += 1);\n    }\n  }\n}\n\nmodule.exports = EthereumService;\n","/**\n @abstract\n**/\nclass TransactionService {\n  _base;\n  _currencyDecimals = 18;\n\n  set base(base) {\n    this._base = base;\n  }\n\n  get base() {\n      return this._base;\n  }\n\n  set currencyDecimals(decimal) {\n      this._currencyDecimals = decimal;\n  }\n\n  get currencyDecimals() {\n      return this._currencyDecimals;\n  }\n\n  verifyAddress(address, publish = true) {}\n  extractAddressData(address, publish = true) {}\n  prepareTransaction() {}\n}\n\nmodule.exports = TransactionService;\n","const TransactionDecorator = require(\"./accountServiceDecorator\");\nconst { ACCOUNT } = require(\"../models/account.model\");\nconst Cryptor = require(\"../helpers/Cryptor\");\nconst {\n  encodeToRlp,\n  verifyEthereumAddress,\n  getEthereumAddressBytes,\n} = require(\"../helpers/ethereumUtils\");\nconst EthereumTransaction = require(\"../models/transactionETH.model\");\nconst { Signature } = require(\"../models/tranasction.model\");\n\nclass TransactionServiceETH extends TransactionDecorator {\n  service = null;\n  _base = ACCOUNT.ETH;\n  _currencyDecimals = 18;\n\n  constructor(service, signer) {\n    this.service = service;\n    this.signer = signer;\n  }\n\n  _signTransaction(transaction) {\n    const payload = encodeToRlp(transaction);\n    const rawDataHash = Buffer.from(\n      Cryptor.keccak256round(payload.toString(\"hex\"), 1),\n      \"hex\"\n    );\n    const signature = this.signer.sign({ data: rawDataHash });\n    console.log(\"ETH signature: \", signature);\n\n    const chainIdV =\n      transaction.chainId != null\n        ? signature.v - 27 + (transaction.chainId * 2 + 35)\n        : signature.v;\n    signature = Signature({\n      v: chainIdV,\n      r: signature.r,\n      s: signature.s,\n    });\n\n    transaction.signature = signature;\n    return transaction;\n  }\n\n  /**\n   * @override\n   */\n  verifyAddress() {\n    const result = verifyEthereumAddress(address);\n    return result;\n  }\n\n  /**\n   * @override\n   */\n  extractAddressData() {\n    return getEthereumAddressBytes(address);\n  }\n\n  /**\n   * @override\n   * @method prepareTransaction\n   * @param {object} param\n   * @param {string} param.to\n   * @param {BigNumber} param.amount\n   * @param {BigNumber} param.gasPrice\n   * @param {BigNumber} param.gasUsed\n   * @param {stringm} param.message\n   * @param {number} param.chainId\n   * @param {number} param.nonce\n   * @returns {ETHTransaction} transaction \n   */\n  prepareTransaction({\n    to,\n    amount,\n    gasPrice,\n    gasUsed,\n    message,\n    chainId,\n    nonce,\n  }) {\n    const transaction = EthereumTransaction.createTransaction({\n      to,\n      amount,\n      gasPrice,\n      gasUsed,\n      message,\n      chainId,\n      fee: gasLimit * gasPrice,\n      nonce,\n    });\n\n    return this._signTransaction(transaction, privKey);\n  }\n}\n\nmodule.exports = TransactionServiceETH;\n","export const randomHex = (n) => {\n  var ID = \"\";\n  var text = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n  n = parseInt(n);\n  if (!(n > 0)) {\n    n = 8;\n  }\n  while (ID.length < n) {\n    ID = ID.concat(text.charAt(parseInt(Math.random() * text.length)));\n  }\n  return ID;\n};\n\nconst pad = (n) => {\n  return n < 10 ? \"0\" + n : n;\n};\n\nexport const to = (promise) => {\n  return promise\n    .then((data) => {\n      return [null, data];\n    })\n    .catch((err) => [err, null]);\n};\n\nconst monthNames = [\n  \"Jan\",\n  \"Feb\",\n  \"Mar\",\n  \"Apr\",\n  \"May\",\n  \"Jun\",\n  \"Jul\",\n  \"Aug\",\n  \"Sep\",\n  \"Oct\",\n  \"Nov\",\n  \"Dec\",\n];\nexport const dateFormatter = (timestamp) => {\n  const dateTime = new Date(timestamp);\n  const date = dateTime.getDate();\n  const month = dateTime.getMonth();\n  const year = dateTime.getFullYear();\n  let hours = dateTime.getHours();\n  const minutes = dateTime.getMinutes();\n  let suffix = \"AM\";\n  if (hours - 12 > 0) {\n    hours -= 12;\n    suffix = \"PM\";\n  }\n  const mmddyyyykkmm =\n    monthNames[month] +\n    \" \" +\n    pad(date) +\n    \", \" +\n    year +\n    \" \" +\n    hours +\n    \":\" +\n    pad(minutes) +\n    \" \" +\n    suffix;\n  return mmddyyyykkmm;\n};\n\nexport const addressFormatter = (address, showLength = 6) => {\n  if (address.length <= showLength * 2) return address;\n  const prefix = address.slice(0, showLength);\n  const suffix = address.slice(address.length - showLength, address.length);\n  return prefix + \"...\" + suffix;\n};\n\nexport const currentView = () => {\n  const scaffold = document.querySelector(\"scaffold-widget\");\n  const view = scaffold?.attributes?.view?.value;\n  return view;\n};\n","module.exports = require(\"axios\");;","module.exports = require(\"bignumber.js\");;","module.exports = require(\"bip39\");;","module.exports = require(\"bitcoinjs-lib\");;","module.exports = require(\"buffer\");;","module.exports = require(\"ethereumjs-util\");;","module.exports = require(\"key-store\");;","module.exports = require(\"rlp\");;","module.exports = require(\"rxjs\");;","module.exports = require(\"web3\");;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\tif (cachedModule.error !== undefined) throw cachedModule.error;\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\ttry {\n\t\tvar execOptions = { id: moduleId, module: module, factory: __webpack_modules__[moduleId], require: __webpack_require__ };\n\t\t__webpack_require__.i.forEach(function(handler) { handler(execOptions); });\n\t\tmodule = execOptions.module;\n\t\texecOptions.factory.call(module.exports, module, module.exports, execOptions.require);\n\t} catch(e) {\n\t\tmodule.error = e;\n\t\tthrow e;\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// expose the module cache\n__webpack_require__.c = __webpack_module_cache__;\n\n// expose the module execution interceptor\n__webpack_require__.i = [];\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","// This function allow to reference all chunks\n__webpack_require__.hu = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".\" + __webpack_require__.h() + \".hot-update.js\";\n};","__webpack_require__.hmrF = () => (\"main.\" + __webpack_require__.h() + \".hot-update.json\");","__webpack_require__.h = () => (\"5bd2b9b27d355eee6a13\")","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"tidebitwallet:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\t;\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var currentModuleData = {};\nvar installedModules = __webpack_require__.c;\n\n// module and require creation\nvar currentChildModule;\nvar currentParents = [];\n\n// status\nvar registeredStatusHandlers = [];\nvar currentStatus = \"idle\";\n\n// while downloading\nvar blockingPromises;\n\n// The update info\nvar currentUpdateApplyHandlers;\nvar queuedInvalidatedModules;\n\n// eslint-disable-next-line no-unused-vars\n__webpack_require__.hmrD = currentModuleData;\n\n__webpack_require__.i.push(function (options) {\n\tvar module = options.module;\n\tvar require = createRequire(options.require, options.id);\n\tmodule.hot = createModuleHotObject(options.id, module);\n\tmodule.parents = currentParents;\n\tmodule.children = [];\n\tcurrentParents = [];\n\toptions.require = require;\n});\n\n__webpack_require__.hmrC = {};\n__webpack_require__.hmrI = {};\n\nfunction createRequire(require, moduleId) {\n\tvar me = installedModules[moduleId];\n\tif (!me) return require;\n\tvar fn = function (request) {\n\t\tif (me.hot.active) {\n\t\t\tif (installedModules[request]) {\n\t\t\t\tvar parents = installedModules[request].parents;\n\t\t\t\tif (parents.indexOf(moduleId) === -1) {\n\t\t\t\t\tparents.push(moduleId);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcurrentParents = [moduleId];\n\t\t\t\tcurrentChildModule = request;\n\t\t\t}\n\t\t\tif (me.children.indexOf(request) === -1) {\n\t\t\t\tme.children.push(request);\n\t\t\t}\n\t\t} else {\n\t\t\tconsole.warn(\n\t\t\t\t\"[HMR] unexpected require(\" +\n\t\t\t\t\trequest +\n\t\t\t\t\t\") from disposed module \" +\n\t\t\t\t\tmoduleId\n\t\t\t);\n\t\t\tcurrentParents = [];\n\t\t}\n\t\treturn require(request);\n\t};\n\tvar createPropertyDescriptor = function (name) {\n\t\treturn {\n\t\t\tconfigurable: true,\n\t\t\tenumerable: true,\n\t\t\tget: function () {\n\t\t\t\treturn require[name];\n\t\t\t},\n\t\t\tset: function (value) {\n\t\t\t\trequire[name] = value;\n\t\t\t}\n\t\t};\n\t};\n\tfor (var name in require) {\n\t\tif (Object.prototype.hasOwnProperty.call(require, name) && name !== \"e\") {\n\t\t\tObject.defineProperty(fn, name, createPropertyDescriptor(name));\n\t\t}\n\t}\n\tfn.e = function (chunkId) {\n\t\treturn trackBlockingPromise(require.e(chunkId));\n\t};\n\treturn fn;\n}\n\nfunction createModuleHotObject(moduleId, me) {\n\tvar _main = currentChildModule !== moduleId;\n\tvar hot = {\n\t\t// private stuff\n\t\t_acceptedDependencies: {},\n\t\t_acceptedErrorHandlers: {},\n\t\t_declinedDependencies: {},\n\t\t_selfAccepted: false,\n\t\t_selfDeclined: false,\n\t\t_selfInvalidated: false,\n\t\t_disposeHandlers: [],\n\t\t_main: _main,\n\t\t_requireSelf: function () {\n\t\t\tcurrentParents = me.parents.slice();\n\t\t\tcurrentChildModule = _main ? undefined : moduleId;\n\t\t\t__webpack_require__(moduleId);\n\t\t},\n\n\t\t// Module API\n\t\tactive: true,\n\t\taccept: function (dep, callback, errorHandler) {\n\t\t\tif (dep === undefined) hot._selfAccepted = true;\n\t\t\telse if (typeof dep === \"function\") hot._selfAccepted = dep;\n\t\t\telse if (typeof dep === \"object\" && dep !== null) {\n\t\t\t\tfor (var i = 0; i < dep.length; i++) {\n\t\t\t\t\thot._acceptedDependencies[dep[i]] = callback || function () {};\n\t\t\t\t\thot._acceptedErrorHandlers[dep[i]] = errorHandler;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\thot._acceptedDependencies[dep] = callback || function () {};\n\t\t\t\thot._acceptedErrorHandlers[dep] = errorHandler;\n\t\t\t}\n\t\t},\n\t\tdecline: function (dep) {\n\t\t\tif (dep === undefined) hot._selfDeclined = true;\n\t\t\telse if (typeof dep === \"object\" && dep !== null)\n\t\t\t\tfor (var i = 0; i < dep.length; i++)\n\t\t\t\t\thot._declinedDependencies[dep[i]] = true;\n\t\t\telse hot._declinedDependencies[dep] = true;\n\t\t},\n\t\tdispose: function (callback) {\n\t\t\thot._disposeHandlers.push(callback);\n\t\t},\n\t\taddDisposeHandler: function (callback) {\n\t\t\thot._disposeHandlers.push(callback);\n\t\t},\n\t\tremoveDisposeHandler: function (callback) {\n\t\t\tvar idx = hot._disposeHandlers.indexOf(callback);\n\t\t\tif (idx >= 0) hot._disposeHandlers.splice(idx, 1);\n\t\t},\n\t\tinvalidate: function () {\n\t\t\tthis._selfInvalidated = true;\n\t\t\tswitch (currentStatus) {\n\t\t\t\tcase \"idle\":\n\t\t\t\t\tcurrentUpdateApplyHandlers = [];\n\t\t\t\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tsetStatus(\"ready\");\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"ready\":\n\t\t\t\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\t\t\tmoduleId,\n\t\t\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t\t\t);\n\t\t\t\t\t});\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"prepare\":\n\t\t\t\tcase \"check\":\n\t\t\t\tcase \"dispose\":\n\t\t\t\tcase \"apply\":\n\t\t\t\t\t(queuedInvalidatedModules = queuedInvalidatedModules || []).push(\n\t\t\t\t\t\tmoduleId\n\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t// ignore requests in error states\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t},\n\n\t\t// Management API\n\t\tcheck: hotCheck,\n\t\tapply: hotApply,\n\t\tstatus: function (l) {\n\t\t\tif (!l) return currentStatus;\n\t\t\tregisteredStatusHandlers.push(l);\n\t\t},\n\t\taddStatusHandler: function (l) {\n\t\t\tregisteredStatusHandlers.push(l);\n\t\t},\n\t\tremoveStatusHandler: function (l) {\n\t\t\tvar idx = registeredStatusHandlers.indexOf(l);\n\t\t\tif (idx >= 0) registeredStatusHandlers.splice(idx, 1);\n\t\t},\n\n\t\t//inherit from previous dispose call\n\t\tdata: currentModuleData[moduleId]\n\t};\n\tcurrentChildModule = undefined;\n\treturn hot;\n}\n\nfunction setStatus(newStatus) {\n\tcurrentStatus = newStatus;\n\tfor (var i = 0; i < registeredStatusHandlers.length; i++)\n\t\tregisteredStatusHandlers[i].call(null, newStatus);\n}\n\nfunction trackBlockingPromise(promise) {\n\tswitch (currentStatus) {\n\t\tcase \"ready\":\n\t\t\tsetStatus(\"prepare\");\n\t\t\tblockingPromises.push(promise);\n\t\t\twaitForBlockingPromises(function () {\n\t\t\t\tsetStatus(\"ready\");\n\t\t\t});\n\t\t\treturn promise;\n\t\tcase \"prepare\":\n\t\t\tblockingPromises.push(promise);\n\t\t\treturn promise;\n\t\tdefault:\n\t\t\treturn promise;\n\t}\n}\n\nfunction waitForBlockingPromises(fn) {\n\tif (blockingPromises.length === 0) return fn();\n\tvar blocker = blockingPromises;\n\tblockingPromises = [];\n\treturn Promise.all(blocker).then(function () {\n\t\treturn waitForBlockingPromises(fn);\n\t});\n}\n\nfunction hotCheck(applyOnUpdate) {\n\tif (currentStatus !== \"idle\") {\n\t\tthrow new Error(\"check() is only allowed in idle status\");\n\t}\n\tsetStatus(\"check\");\n\treturn __webpack_require__.hmrM().then(function (update) {\n\t\tif (!update) {\n\t\t\tsetStatus(applyInvalidatedModules() ? \"ready\" : \"idle\");\n\t\t\treturn null;\n\t\t}\n\n\t\tsetStatus(\"prepare\");\n\n\t\tvar updatedModules = [];\n\t\tblockingPromises = [];\n\t\tcurrentUpdateApplyHandlers = [];\n\n\t\treturn Promise.all(\n\t\t\tObject.keys(__webpack_require__.hmrC).reduce(function (\n\t\t\t\tpromises,\n\t\t\t\tkey\n\t\t\t) {\n\t\t\t\t__webpack_require__.hmrC[key](\n\t\t\t\t\tupdate.c,\n\t\t\t\t\tupdate.r,\n\t\t\t\t\tupdate.m,\n\t\t\t\t\tpromises,\n\t\t\t\t\tcurrentUpdateApplyHandlers,\n\t\t\t\t\tupdatedModules\n\t\t\t\t);\n\t\t\t\treturn promises;\n\t\t\t},\n\t\t\t[])\n\t\t).then(function () {\n\t\t\treturn waitForBlockingPromises(function () {\n\t\t\t\tif (applyOnUpdate) {\n\t\t\t\t\treturn internalApply(applyOnUpdate);\n\t\t\t\t} else {\n\t\t\t\t\tsetStatus(\"ready\");\n\n\t\t\t\t\treturn updatedModules;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t});\n}\n\nfunction hotApply(options) {\n\tif (currentStatus !== \"ready\") {\n\t\treturn Promise.resolve().then(function () {\n\t\t\tthrow new Error(\"apply() is only allowed in ready status\");\n\t\t});\n\t}\n\treturn internalApply(options);\n}\n\nfunction internalApply(options) {\n\toptions = options || {};\n\n\tapplyInvalidatedModules();\n\n\tvar results = currentUpdateApplyHandlers.map(function (handler) {\n\t\treturn handler(options);\n\t});\n\tcurrentUpdateApplyHandlers = undefined;\n\n\tvar errors = results\n\t\t.map(function (r) {\n\t\t\treturn r.error;\n\t\t})\n\t\t.filter(Boolean);\n\n\tif (errors.length > 0) {\n\t\tsetStatus(\"abort\");\n\t\treturn Promise.resolve().then(function () {\n\t\t\tthrow errors[0];\n\t\t});\n\t}\n\n\t// Now in \"dispose\" phase\n\tsetStatus(\"dispose\");\n\n\tresults.forEach(function (result) {\n\t\tif (result.dispose) result.dispose();\n\t});\n\n\t// Now in \"apply\" phase\n\tsetStatus(\"apply\");\n\n\tvar error;\n\tvar reportError = function (err) {\n\t\tif (!error) error = err;\n\t};\n\n\tvar outdatedModules = [];\n\tresults.forEach(function (result) {\n\t\tif (result.apply) {\n\t\t\tvar modules = result.apply(reportError);\n\t\t\tif (modules) {\n\t\t\t\tfor (var i = 0; i < modules.length; i++) {\n\t\t\t\t\toutdatedModules.push(modules[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t});\n\n\t// handle errors in accept handlers and self accepted module load\n\tif (error) {\n\t\tsetStatus(\"fail\");\n\t\treturn Promise.resolve().then(function () {\n\t\t\tthrow error;\n\t\t});\n\t}\n\n\tif (queuedInvalidatedModules) {\n\t\treturn internalApply(options).then(function (list) {\n\t\t\toutdatedModules.forEach(function (moduleId) {\n\t\t\t\tif (list.indexOf(moduleId) < 0) list.push(moduleId);\n\t\t\t});\n\t\t\treturn list;\n\t\t});\n\t}\n\n\tsetStatus(\"idle\");\n\treturn Promise.resolve(outdatedModules);\n}\n\nfunction applyInvalidatedModules() {\n\tif (queuedInvalidatedModules) {\n\t\tif (!currentUpdateApplyHandlers) currentUpdateApplyHandlers = [];\n\t\tObject.keys(__webpack_require__.hmrI).forEach(function (key) {\n\t\t\tqueuedInvalidatedModules.forEach(function (moduleId) {\n\t\t\t\t__webpack_require__.hmrI[key](\n\t\t\t\t\tmoduleId,\n\t\t\t\t\tcurrentUpdateApplyHandlers\n\t\t\t\t);\n\t\t\t});\n\t\t});\n\t\tqueuedInvalidatedModules = undefined;\n\t\treturn true;\n\t}\n}","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) scriptUrl = scripts[scripts.length - 1].src\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"main\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\nvar currentUpdatedModulesList;\nvar waitingUpdateResolves = {};\nfunction loadUpdateChunk(chunkId) {\n\treturn new Promise((resolve, reject) => {\n\t\twaitingUpdateResolves[chunkId] = resolve;\n\t\t// start update chunk loading\n\t\tvar url = __webpack_require__.p + __webpack_require__.hu(chunkId);\n\t\t// create error before stack unwound to get useful stacktrace later\n\t\tvar error = new Error();\n\t\tvar loadingEnded = (event) => {\n\t\t\tif(waitingUpdateResolves[chunkId]) {\n\t\t\t\twaitingUpdateResolves[chunkId] = undefined\n\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\terror.message = 'Loading hot update chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\terror.type = errorType;\n\t\t\t\terror.request = realSrc;\n\t\t\t\treject(error);\n\t\t\t}\n\t\t};\n\t\t__webpack_require__.l(url, loadingEnded);\n\t});\n}\n\nself[\"webpackHotUpdatetidebitwallet\"] = (chunkId, moreModules, runtime) => {\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\tcurrentUpdate[moduleId] = moreModules[moduleId];\n\t\t\tif(currentUpdatedModulesList) currentUpdatedModulesList.push(moduleId);\n\t\t}\n\t}\n\tif(runtime) currentUpdateRuntime.push(runtime);\n\tif(waitingUpdateResolves[chunkId]) {\n\t\twaitingUpdateResolves[chunkId]();\n\t\twaitingUpdateResolves[chunkId] = undefined;\n\t}\n};\n\nvar currentUpdateChunks;\nvar currentUpdate;\nvar currentUpdateRemovedChunks;\nvar currentUpdateRuntime;\nfunction applyHandler(options) {\n\tif (__webpack_require__.f) delete __webpack_require__.f.jsonpHmr;\n\tcurrentUpdateChunks = undefined;\n\tfunction getAffectedModuleEffects(updateModuleId) {\n\t\tvar outdatedModules = [updateModuleId];\n\t\tvar outdatedDependencies = {};\n\n\t\tvar queue = outdatedModules.map(function (id) {\n\t\t\treturn {\n\t\t\t\tchain: [id],\n\t\t\t\tid: id\n\t\t\t};\n\t\t});\n\t\twhile (queue.length > 0) {\n\t\t\tvar queueItem = queue.pop();\n\t\t\tvar moduleId = queueItem.id;\n\t\t\tvar chain = queueItem.chain;\n\t\t\tvar module = __webpack_require__.c[moduleId];\n\t\t\tif (\n\t\t\t\t!module ||\n\t\t\t\t(module.hot._selfAccepted && !module.hot._selfInvalidated)\n\t\t\t)\n\t\t\t\tcontinue;\n\t\t\tif (module.hot._selfDeclined) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"self-declined\",\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (module.hot._main) {\n\t\t\t\treturn {\n\t\t\t\t\ttype: \"unaccepted\",\n\t\t\t\t\tchain: chain,\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\tfor (var i = 0; i < module.parents.length; i++) {\n\t\t\t\tvar parentId = module.parents[i];\n\t\t\t\tvar parent = __webpack_require__.c[parentId];\n\t\t\t\tif (!parent) continue;\n\t\t\t\tif (parent.hot._declinedDependencies[moduleId]) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\ttype: \"declined\",\n\t\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\tparentId: parentId\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (outdatedModules.indexOf(parentId) !== -1) continue;\n\t\t\t\tif (parent.hot._acceptedDependencies[moduleId]) {\n\t\t\t\t\tif (!outdatedDependencies[parentId])\n\t\t\t\t\t\toutdatedDependencies[parentId] = [];\n\t\t\t\t\taddAllToSet(outdatedDependencies[parentId], [moduleId]);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdelete outdatedDependencies[parentId];\n\t\t\t\toutdatedModules.push(parentId);\n\t\t\t\tqueue.push({\n\t\t\t\t\tchain: chain.concat([parentId]),\n\t\t\t\t\tid: parentId\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\treturn {\n\t\t\ttype: \"accepted\",\n\t\t\tmoduleId: updateModuleId,\n\t\t\toutdatedModules: outdatedModules,\n\t\t\toutdatedDependencies: outdatedDependencies\n\t\t};\n\t}\n\n\tfunction addAllToSet(a, b) {\n\t\tfor (var i = 0; i < b.length; i++) {\n\t\t\tvar item = b[i];\n\t\t\tif (a.indexOf(item) === -1) a.push(item);\n\t\t}\n\t}\n\n\t// at begin all updates modules are outdated\n\t// the \"outdated\" status can propagate to parents if they don't accept the children\n\tvar outdatedDependencies = {};\n\tvar outdatedModules = [];\n\tvar appliedUpdate = {};\n\n\tvar warnUnexpectedRequire = function warnUnexpectedRequire(module) {\n\t\tconsole.warn(\n\t\t\t\"[HMR] unexpected require(\" + module.id + \") to disposed module\"\n\t\t);\n\t};\n\n\tfor (var moduleId in currentUpdate) {\n\t\tif (__webpack_require__.o(currentUpdate, moduleId)) {\n\t\t\tvar newModuleFactory = currentUpdate[moduleId];\n\t\t\t/** @type {TODO} */\n\t\t\tvar result;\n\t\t\tif (newModuleFactory) {\n\t\t\t\tresult = getAffectedModuleEffects(moduleId);\n\t\t\t} else {\n\t\t\t\tresult = {\n\t\t\t\t\ttype: \"disposed\",\n\t\t\t\t\tmoduleId: moduleId\n\t\t\t\t};\n\t\t\t}\n\t\t\t/** @type {Error|false} */\n\t\t\tvar abortError = false;\n\t\t\tvar doApply = false;\n\t\t\tvar doDispose = false;\n\t\t\tvar chainInfo = \"\";\n\t\t\tif (result.chain) {\n\t\t\t\tchainInfo = \"\\nUpdate propagation: \" + result.chain.join(\" -> \");\n\t\t\t}\n\t\t\tswitch (result.type) {\n\t\t\t\tcase \"self-declined\":\n\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because of self decline: \" +\n\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"declined\":\n\t\t\t\t\tif (options.onDeclined) options.onDeclined(result);\n\t\t\t\t\tif (!options.ignoreDeclined)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because of declined dependency: \" +\n\t\t\t\t\t\t\t\tresult.moduleId +\n\t\t\t\t\t\t\t\t\" in \" +\n\t\t\t\t\t\t\t\tresult.parentId +\n\t\t\t\t\t\t\t\tchainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"unaccepted\":\n\t\t\t\t\tif (options.onUnaccepted) options.onUnaccepted(result);\n\t\t\t\t\tif (!options.ignoreUnaccepted)\n\t\t\t\t\t\tabortError = new Error(\n\t\t\t\t\t\t\t\"Aborted because \" + moduleId + \" is not accepted\" + chainInfo\n\t\t\t\t\t\t);\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"accepted\":\n\t\t\t\t\tif (options.onAccepted) options.onAccepted(result);\n\t\t\t\t\tdoApply = true;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"disposed\":\n\t\t\t\t\tif (options.onDisposed) options.onDisposed(result);\n\t\t\t\t\tdoDispose = true;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(\"Unexception type \" + result.type);\n\t\t\t}\n\t\t\tif (abortError) {\n\t\t\t\treturn {\n\t\t\t\t\terror: abortError\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (doApply) {\n\t\t\t\tappliedUpdate[moduleId] = newModuleFactory;\n\t\t\t\taddAllToSet(outdatedModules, result.outdatedModules);\n\t\t\t\tfor (moduleId in result.outdatedDependencies) {\n\t\t\t\t\tif (__webpack_require__.o(result.outdatedDependencies, moduleId)) {\n\t\t\t\t\t\tif (!outdatedDependencies[moduleId])\n\t\t\t\t\t\t\toutdatedDependencies[moduleId] = [];\n\t\t\t\t\t\taddAllToSet(\n\t\t\t\t\t\t\toutdatedDependencies[moduleId],\n\t\t\t\t\t\t\tresult.outdatedDependencies[moduleId]\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (doDispose) {\n\t\t\t\taddAllToSet(outdatedModules, [result.moduleId]);\n\t\t\t\tappliedUpdate[moduleId] = warnUnexpectedRequire;\n\t\t\t}\n\t\t}\n\t}\n\tcurrentUpdate = undefined;\n\n\t// Store self accepted outdated modules to require them later by the module system\n\tvar outdatedSelfAcceptedModules = [];\n\tfor (var j = 0; j < outdatedModules.length; j++) {\n\t\tvar outdatedModuleId = outdatedModules[j];\n\t\tvar module = __webpack_require__.c[outdatedModuleId];\n\t\tif (\n\t\t\tmodule &&\n\t\t\t(module.hot._selfAccepted || module.hot._main) &&\n\t\t\t// removed self-accepted modules should not be required\n\t\t\tappliedUpdate[outdatedModuleId] !== warnUnexpectedRequire &&\n\t\t\t// when called invalidate self-accepting is not possible\n\t\t\t!module.hot._selfInvalidated\n\t\t) {\n\t\t\toutdatedSelfAcceptedModules.push({\n\t\t\t\tmodule: outdatedModuleId,\n\t\t\t\trequire: module.hot._requireSelf,\n\t\t\t\terrorHandler: module.hot._selfAccepted\n\t\t\t});\n\t\t}\n\t}\n\n\tvar moduleOutdatedDependencies;\n\n\treturn {\n\t\tdispose: function () {\n\t\t\tcurrentUpdateRemovedChunks.forEach(function (chunkId) {\n\t\t\t\tdelete installedChunks[chunkId];\n\t\t\t});\n\t\t\tcurrentUpdateRemovedChunks = undefined;\n\n\t\t\tvar idx;\n\t\t\tvar queue = outdatedModules.slice();\n\t\t\twhile (queue.length > 0) {\n\t\t\t\tvar moduleId = queue.pop();\n\t\t\t\tvar module = __webpack_require__.c[moduleId];\n\t\t\t\tif (!module) continue;\n\n\t\t\t\tvar data = {};\n\n\t\t\t\t// Call dispose handlers\n\t\t\t\tvar disposeHandlers = module.hot._disposeHandlers;\n\t\t\t\tfor (j = 0; j < disposeHandlers.length; j++) {\n\t\t\t\t\tdisposeHandlers[j].call(null, data);\n\t\t\t\t}\n\t\t\t\t__webpack_require__.hmrD[moduleId] = data;\n\n\t\t\t\t// disable module (this disables requires from this module)\n\t\t\t\tmodule.hot.active = false;\n\n\t\t\t\t// remove module from cache\n\t\t\t\tdelete __webpack_require__.c[moduleId];\n\n\t\t\t\t// when disposing there is no need to call dispose handler\n\t\t\t\tdelete outdatedDependencies[moduleId];\n\n\t\t\t\t// remove \"parents\" references from all children\n\t\t\t\tfor (j = 0; j < module.children.length; j++) {\n\t\t\t\t\tvar child = __webpack_require__.c[module.children[j]];\n\t\t\t\t\tif (!child) continue;\n\t\t\t\t\tidx = child.parents.indexOf(moduleId);\n\t\t\t\t\tif (idx >= 0) {\n\t\t\t\t\t\tchild.parents.splice(idx, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// remove outdated dependency from module children\n\t\t\tvar dependency;\n\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\tif (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\tmodule = __webpack_require__.c[outdatedModuleId];\n\t\t\t\t\tif (module) {\n\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\tfor (j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\tdependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\tidx = module.children.indexOf(dependency);\n\t\t\t\t\t\t\tif (idx >= 0) module.children.splice(idx, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tapply: function (reportError) {\n\t\t\t// insert new code\n\t\t\tfor (var updateModuleId in appliedUpdate) {\n\t\t\t\tif (__webpack_require__.o(appliedUpdate, updateModuleId)) {\n\t\t\t\t\t__webpack_require__.m[updateModuleId] = appliedUpdate[updateModuleId];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// run new runtime modules\n\t\t\tfor (var i = 0; i < currentUpdateRuntime.length; i++) {\n\t\t\t\tcurrentUpdateRuntime[i](__webpack_require__);\n\t\t\t}\n\n\t\t\t// call accept handlers\n\t\t\tfor (var outdatedModuleId in outdatedDependencies) {\n\t\t\t\tif (__webpack_require__.o(outdatedDependencies, outdatedModuleId)) {\n\t\t\t\t\tvar module = __webpack_require__.c[outdatedModuleId];\n\t\t\t\t\tif (module) {\n\t\t\t\t\t\tmoduleOutdatedDependencies =\n\t\t\t\t\t\t\toutdatedDependencies[outdatedModuleId];\n\t\t\t\t\t\tvar callbacks = [];\n\t\t\t\t\t\tvar errorHandlers = [];\n\t\t\t\t\t\tvar dependenciesForCallbacks = [];\n\t\t\t\t\t\tfor (var j = 0; j < moduleOutdatedDependencies.length; j++) {\n\t\t\t\t\t\t\tvar dependency = moduleOutdatedDependencies[j];\n\t\t\t\t\t\t\tvar acceptCallback =\n\t\t\t\t\t\t\t\tmodule.hot._acceptedDependencies[dependency];\n\t\t\t\t\t\t\tvar errorHandler =\n\t\t\t\t\t\t\t\tmodule.hot._acceptedErrorHandlers[dependency];\n\t\t\t\t\t\t\tif (acceptCallback) {\n\t\t\t\t\t\t\t\tif (callbacks.indexOf(acceptCallback) !== -1) continue;\n\t\t\t\t\t\t\t\tcallbacks.push(acceptCallback);\n\t\t\t\t\t\t\t\terrorHandlers.push(errorHandler);\n\t\t\t\t\t\t\t\tdependenciesForCallbacks.push(dependency);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (var k = 0; k < callbacks.length; k++) {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tcallbacks[k].call(null, moduleOutdatedDependencies);\n\t\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t\tif (typeof errorHandlers[k] === \"function\") {\n\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\terrorHandlers[k](err, {\n\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k]\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\t\terror: err2,\n\t\t\t\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\t\treportError(err2);\n\t\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\t\t\ttype: \"accept-errored\",\n\t\t\t\t\t\t\t\t\t\t\tmoduleId: outdatedModuleId,\n\t\t\t\t\t\t\t\t\t\t\tdependencyId: dependenciesForCallbacks[k],\n\t\t\t\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Load self accepted modules\n\t\t\tfor (var o = 0; o < outdatedSelfAcceptedModules.length; o++) {\n\t\t\t\tvar item = outdatedSelfAcceptedModules[o];\n\t\t\t\tvar moduleId = item.module;\n\t\t\t\ttry {\n\t\t\t\t\titem.require(moduleId);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tif (typeof item.errorHandler === \"function\") {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\titem.errorHandler(err, {\n\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\tmodule: __webpack_require__.c[moduleId]\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} catch (err2) {\n\t\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\t\ttype: \"self-accept-error-handler-errored\",\n\t\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\t\terror: err2,\n\t\t\t\t\t\t\t\t\toriginalError: err\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\t\treportError(err2);\n\t\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (options.onErrored) {\n\t\t\t\t\t\t\toptions.onErrored({\n\t\t\t\t\t\t\t\ttype: \"self-accept-errored\",\n\t\t\t\t\t\t\t\tmoduleId: moduleId,\n\t\t\t\t\t\t\t\terror: err\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!options.ignoreErrored) {\n\t\t\t\t\t\t\treportError(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn outdatedModules;\n\t\t}\n\t};\n}\n__webpack_require__.hmrI.jsonp = function (moduleId, applyHandlers) {\n\tif (!currentUpdate) {\n\t\tcurrentUpdate = {};\n\t\tcurrentUpdateRuntime = [];\n\t\tcurrentUpdateRemovedChunks = [];\n\t\tapplyHandlers.push(applyHandler);\n\t}\n\tif (!__webpack_require__.o(currentUpdate, moduleId)) {\n\t\tcurrentUpdate[moduleId] = __webpack_require__.m[moduleId];\n\t}\n};\n__webpack_require__.hmrC.jsonp = function (\n\tchunkIds,\n\tremovedChunks,\n\tremovedModules,\n\tpromises,\n\tapplyHandlers,\n\tupdatedModulesList\n) {\n\tapplyHandlers.push(applyHandler);\n\tcurrentUpdateChunks = {};\n\tcurrentUpdateRemovedChunks = removedChunks;\n\tcurrentUpdate = removedModules.reduce(function (obj, key) {\n\t\tobj[key] = false;\n\t\treturn obj;\n\t}, {});\n\tcurrentUpdateRuntime = [];\n\tchunkIds.forEach(function (chunkId) {\n\t\tif (\n\t\t\t__webpack_require__.o(installedChunks, chunkId) &&\n\t\t\tinstalledChunks[chunkId] !== undefined\n\t\t) {\n\t\t\tpromises.push(loadUpdateChunk(chunkId, updatedModulesList));\n\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t}\n\t});\n\tif (__webpack_require__.f) {\n\t\t__webpack_require__.f.jsonpHmr = function (chunkId, promises) {\n\t\t\tif (\n\t\t\t\tcurrentUpdateChunks &&\n\t\t\t\t!__webpack_require__.o(currentUpdateChunks, chunkId) &&\n\t\t\t\t__webpack_require__.o(installedChunks, chunkId) &&\n\t\t\t\tinstalledChunks[chunkId] !== undefined\n\t\t\t) {\n\t\t\t\tpromises.push(loadUpdateChunk(chunkId));\n\t\t\t\tcurrentUpdateChunks[chunkId] = true;\n\t\t\t}\n\t\t};\n\t}\n};\n\n__webpack_require__.hmrM = () => {\n\tif (typeof fetch === \"undefined\") throw new Error(\"No browser support: need fetch API\");\n\treturn fetch(__webpack_require__.p + __webpack_require__.hmrF()).then((response) => {\n\t\tif(response.status === 404) return; // no update available\n\t\tif(!response.ok) throw new Error(\"Failed to fetch update manifest \" + response.statusText);\n\t\treturn response.json();\n\t});\n};\n\n// no on chunks loaded\n\n// no jsonp function","// module cache are used so entry inlining is disabled\n// startup\n// Load entry module and return exports\nvar __webpack_exports__ = __webpack_require__(\"./src/background.js\");\n"],"mappings":";;;;;;;;;;;;;;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AACA;;A;;;;;;;;ACLA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;;A;;;;;;;;ACXA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAHA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AAKA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAjCA;AAmCA;AACA;AAhVA;AACA;AAiVA;;A;;;;;;;;AC3VA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAnJA;AACA;AAoJA;;A;;;;;;;;AC1JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AACA;AASA;;A;;;;;;;;;ACVA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAlDA;AACA;AAmDA;;A;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAKA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAltBA;AACA;AAqtBA;;A;;;;;;;;;ACxtBA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAIA;AAoBA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAJA;AACA;AAMA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAMA;AAIA;AAIA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAzUA;AACA;AA0UA;;A;;;;;;;;ACjVA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AADA;AAMA;AAAA;AADA;AAKA;AAEA;AAEA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAHA;AAKA;AAGA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AArKA;AACA;AAsKA;;A;;;;;;;;ACzKA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AAAA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3VA;AACA;AA4VA;;A;;;;;;;;AClWA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7DA;AACA;AA8DA;;A;;;;;;;;AClEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAIA;AACA;AADA;AAGA;AAEA;AACA;AADA;AAGA;AAEA;AACA;AADA;AAIA;AACA;AADA;AAIA;AACA;AADA;AAIA;AACA;AADA;AAGA;AAKA;AACA;AADA;AAIA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1IA;AACA;AA2IA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA5JA;AACA;AA6JA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1CA;AACA;AA2CA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhCA;AACA;AAiCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlDA;AACA;AAmDA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAvBA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAnDA;AACA;AAoDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjDA;AACA;AAkDA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AACA;AAsBA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAzCA;AA4CA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;;A;;;;;;;;;AC3pBA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAhCA;AACA;AAiCA;;A;;;;;;;;ACxCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AApBA;AACA;AAqBA;;A;;;;;;;;ACxBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;;A;;;;;;;;;ACRA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;;A;;;;;;;;AClGA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AADA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAnEA;AACA;AAoEA;;A;;;;;;;;;ACvEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AACA;AA0CA;;A;;;;;;;;AC3CA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AALA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlKA;AACA;AAmKA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAFA;AAIA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;A;;;;;;;;ACnNA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAFA;;A;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AACA;AAwBA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AANA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AALA;;A;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAbA;AAmBA;AACA;AA/CA;AACA;AAgDA;;A;;;;;;;;AC1DA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9DA;AACA;AA+DA;;A;;;;;;;;ACnEA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAIA;AAEA;AAFA;AAKA;AAEA;AACA;AACA;AAFA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAFA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAGA;AAFA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AAEA;AACA;AACA;AACA;AACA;AADA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AAFA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AACA;AASA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAtVA;AACA;AAuVA;;A;;;;;;;;AC1VA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AACA;AAWA;;A;;;;;;;;;ACjBA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AAIA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AADA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAHA;AACA;AAKA;AAAA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAJA;AACA;AAMA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/RA;AACA;AAgSA;;A;;;;;;;;ACpSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAvBA;AACA;AAwBA;;A;;;;;;;;;AC5BA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAHA;AACA;AAIA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AAnFA;AACA;AAoFA;;A;;;;;;;;;;;;;;;;;AChGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;A;;;;;;;;;A;;A;;;;;;;;;AC7EA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;;;;;;ACAA;;A;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;;;;;ACJA;;;;;ACAA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACzCA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC7WA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC5fA;AACA;AACA;AACA;;;A","sourceRoot":""}